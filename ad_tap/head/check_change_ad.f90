!        Generated by TAPENADE     (INRIA, Ecuador team)
!  tapenade 3.x
!
!  Differentiation of check_change in reverse (adjoint) mode (with options noISIZE i8):
!   gradient     of useful results: *x old new difmax
!   with respect to varying inputs: *x old new
!   Plus diff mem management of: x:in
! MIT License
!
! Copyright (c) 2020 SHEMAT-Suite
!
! Permission is hereby granted, free of charge, to any person obtaining a copy
! of this software and associated documentation files (the "Software"), to deal
! in the Software without restriction, including without limitation the rights
! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
! copies of the Software, and to permit persons to whom the Software is
! furnished to do so, subject to the following conditions:
!
! The above copyright notice and this permission notice shall be included in all
! copies or substantial portions of the Software.
!
! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
! SOFTWARE.
!>    @brief check changes between vectors [new] and [old]
!>    @param[in] mode switch absolute/relative
!>    @param[out] rms return value
!>    @param[out] difmax maximal difference
!>    @param[in] ni I-dimension for vectors [new], [old]
!>    @param[in] nj J-dimension for vectors [new], [old]
!>    @param[in] nk K-dimension for vectors [new], [old]
!>    @param[in] new vector with new values
!>    @param[in] old vector with old values
!>    @param[in] pv_idx index number (physical value), only needed for AD code generation/modification
!>    @param[out] loc_nltol tolerance criteria, only needed for AD code generation/modification
!>    @param[in] ismpl local sample index
!>    @details
!> Computes two difference metrics between the physical variable array
!> of this iteration (new) and the one from the previous iteration
!> (old): \n\n
!>
!> 1. difmax  : max. difference of fields new and old\n
!>    mode= 0 : difmax is absolute maximum difference\n
!>    else    : difmax is relative maximum difference\n\n
!>
!> 2. rms     : root mean square difference of fields new and old
!>    mode= 0 : rms is root mean square of absolute differences\n
!>    else    : rms is root mean square of relative differences\n\n
SUBROUTINE CHECK_CHANGE_AD(mode, pv_idx, loc_nltol, rms, difmax, &
& difmax_ad, ni, nj, nk, new, new_ad, old, old_ad, ismpl)
  use arrays

  USE ARRAYS_AD

  USE MOD_LINFOS
  IMPLICIT NONE
  INTEGER :: i, j, k, ni, nj, nk, ijk, ipt, jpt, kpt, mode, pv_idx, &
& ismpl
  DOUBLE PRECISION :: new(ni, nj, nk), old(ni, nj, nk)
  DOUBLE PRECISION :: new_ad(ni, nj, nk), old_ad(ni, nj, nk)
! DOUBLE PRECISION dif
  DOUBLE PRECISION :: rms, difmax, loc_nltol
  DOUBLE PRECISION :: difmax_ad
  EXTERNAL IDAMAX
  INTEGER :: IDAMAX
  INTRINSIC DABS, DBLE, SQRT
  DOUBLE PRECISION :: dabs0
  DOUBLE PRECISION :: dummydiff_ad
  DOUBLE PRECISION :: dummydiff_ad0
  DOUBLE PRECISION :: temporary_ad
  INTEGER :: branch
! Initial values for output
  IF (mode .EQ. 0) THEN
! Absolute difference
! Number of cells
    ijk = ni*nj*nk
! Copy new values to x
    CALL DCOPY(ijk, new, 1, x(1, 1, 1, ismpl), 1)
! Absolute difference array: new - old
    CALL DAXPY(ijk, -1.0d0, old, 1, x(1, 1, 1, ismpl), 1)
! Indices of maximum absolute difference
    i = IDAMAX(ijk, x(1, 1, 1, ismpl), 1)
    CALL IJK_M(i, ipt, jpt, kpt)
! Maximum absolute difference
! Sum of squares
    x_ad(ipt, jpt, kpt, ismpl) = x_ad(ipt, jpt, kpt, ismpl) + difmax_ad
    CALL DAXPY_AD(ijk, -1.0d0, dummydiff_ad, old, old_ad, 1, x(1, 1, 1, &
&           ismpl), x_ad(1, 1, 1, ismpl), 1)
    CALL DCOPY_AD(ijk, new, new_ad, 1, x(1, 1, 1, ismpl), x_ad(1, 1, 1, &
&           ismpl), 1)
  ELSE
! Relative difference (currently not used)
! Number of cells
    ijk = ni*nj*nk
! Copy new values to x
    CALL DCOPY(ijk, new, 1, x(1, 1, 1, ismpl), 1)
! Relative difference array (new - old)/old
    CALL DAXPY(ijk, -1.0d0, old, 1, x(1, 1, 1, ismpl), 1)
    DO k=1,nk
      DO j=1,nj
        DO i=1,ni
          IF (old(i, j, k) .GE. 0.) THEN
            dabs0 = old(i, j, k)
          ELSE
            dabs0 = -old(i, j, k)
          END IF
          IF (dabs0 .GT. 1.d-200) THEN
            CALL PUSHREAL8(x(i, j, k, ismpl))
            x(i, j, k, ismpl) = x(i, j, k, ismpl)/old(i, j, k)
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
      END DO
    END DO
! Indices of maximum relative difference
    i = IDAMAX(ijk, x(1, 1, 1, ismpl), 1)
    CALL IJK_M(i, ipt, jpt, kpt)
! Maximum relative difference
! Sum of squares
    x_ad(ipt, jpt, kpt, ismpl) = x_ad(ipt, jpt, kpt, ismpl) + difmax_ad
    DO k=nk,1,-1
      DO j=nj,1,-1
        DO i=ni,1,-1
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            CALL POPREAL8(x(i, j, k, ismpl))
            temporary_ad = x_ad(i, j, k, ismpl)/old(i, j, k)
            x_ad(i, j, k, ismpl) = temporary_ad
            old_ad(i, j, k) = old_ad(i, j, k) - x(i, j, k, ismpl)*&
&             temporary_ad/old(i, j, k)
          END IF
        END DO
      END DO
    END DO
    CALL DAXPY_AD(ijk, -1.0d0, dummydiff_ad0, old, old_ad, 1, x(1, 1, 1&
&           , ismpl), x_ad(1, 1, 1, ismpl), 1)
    CALL DCOPY_AD(ijk, new, new_ad, 1, x(1, 1, 1, ismpl), x_ad(1, 1, 1, &
&           ismpl), 1)
  END IF
END SUBROUTINE CHECK_CHANGE_AD

