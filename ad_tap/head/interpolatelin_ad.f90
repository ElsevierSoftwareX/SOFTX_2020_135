!        Generated by TAPENADE     (INRIA, Ecuador team)
!  tapenade 3.x
!
!  Differentiation of interpolatelin in reverse (adjoint) mode (with options noISIZE i8):
!   gradient     of useful results: interpolatelin vals
!   with respect to varying inputs: vals
! MIT License
!
! Copyright (c) 2020 SHEMAT-Suite
!
! Permission is hereby granted, free of charge, to any person obtaining a copy
! of this software and associated documentation files (the "Software"), to deal
! in the Software without restriction, including without limitation the rights
! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
! copies of the Software, and to permit persons to whom the Software is
! furnished to do so, subject to the following conditions:
!
! The above copyright notice and this permission notice shall be included in all
! copies or substantial portions of the Software.
!
! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
! SOFTWARE.
!>    @brief inter cell interpolation
!>    @param[in] I0 i-dimension
!>    @param[in] J0 j-dimension
!>    @param[in] K0 k-dimension
!>    @param[in] i cell index, direction I0
!>    @param[in] j cell index, direction J0
!>    @param[in] k cell index, direction K0
!>    @param[in] vals state variables (values)
!>    @param[in] px I0-direction interpolation position
!>    @param[in] py J0-direction interpolation position
!>    @param[in] pz K0-direction interpolation position
!>    @param[in] delx I0-direction cell dimensions (delta size)
!>    @param[in] dely J0-direction cell dimensions (delta size)
!>    @param[in] delz K0-direction cell dimensions (delta size)
!>    @param[in] delxa I0-direction absolute cell positions
!>    @param[in] delya J0-direction absolute cell positions
!>    @param[in] delza K0-direction absolute cell positions
!>    @return interpolated value
SUBROUTINE INTERPOLATELIN_AD(i0, j0, k0, i, j, k, vals, vals_ad, px, py&
& , pz, delx, dely, delz, delxa, delya, delza, interpolatelin_adv)
  IMPLICIT NONE
  double precision :: interpolatelin_adv
!       i,j,k cell index (first corner - 3D)
  INTEGER :: i, j, k, i0, j0, k0
!       neighbours i,j,k cell index (second corner - 3D)
  INTEGER :: ni, nj, nk
!       state variables (values)
  DOUBLE PRECISION :: vals(i0, j0, k0)
  DOUBLE PRECISION :: vals_ad(i0, j0, k0)
!       x,y,z cell dimensions (delta size)
  DOUBLE PRECISION :: delx(i0), dely(j0), delz(k0)
!       x,y,z absolute cell position
  DOUBLE PRECISION :: delxa(i0), delya(j0), delza(k0)
!       x,y,z interpolation position
  DOUBLE PRECISION :: px, py, pz
!
  DOUBLE PRECISION :: d_a0, d_b0, d_a1, d_b1, d_a2, d_b2
  DOUBLE PRECISION :: d_a0_ad, d_b0_ad, d_a1_ad, d_b1_ad, d_a2_ad, &
& d_b2_ad
  EXTERNAL LIN_INTERPOL
  EXTERNAL LIN_INTERPOL_AD0
  DOUBLE PRECISION :: LIN_INTERPOL
  INTRINSIC MIN, MAX, ABS
  INTEGER :: x1
  INTEGER :: x2
  INTEGER :: x3
  DOUBLE PRECISION :: abs0
  DOUBLE PRECISION :: abs1
  DOUBLE PRECISION :: abs2
  DOUBLE PRECISION :: abs3
  DOUBLE PRECISION :: abs4
  DOUBLE PRECISION :: abs5
  DOUBLE PRECISION :: abs6
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: interpolatelin
!       get neighbour i-index
  ni = i + 1
  IF (px .LT. delxa(i)) ni = i - 1
  IF (ni .LT. 1) THEN
    x1 = 1
  ELSE
    x1 = ni
  END IF
  IF (x1 .GT. i0) THEN
    ni = i0
  ELSE
    ni = x1
  END IF
!       get neighbour j-index
  nj = j + 1
  IF (py .LT. delya(j)) nj = j - 1
  IF (nj .LT. 1) THEN
    x2 = 1
  ELSE
    x2 = nj
  END IF
  IF (x2 .GT. j0) THEN
    nj = j0
  ELSE
    nj = x2
  END IF
!       get neighbour k-index
  nk = k + 1
  IF (pz .LT. delza(k)) nk = k - 1
  IF (nk .LT. 1) THEN
    x3 = 1
  ELSE
    x3 = nk
  END IF
  IF (x3 .GT. k0) THEN
    nk = k0
  ELSE
    nk = x3
  END IF
!
!       x1
!       x2
  IF (delxa(i) - px .GE. 0.) THEN
    abs0 = delxa(i) - px
  ELSE
    abs0 = -(delxa(i)-px)
  END IF
!       y1
!
!       x1
!       x2
  IF (delxa(i) - px .GE. 0.) THEN
    abs1 = delxa(i) - px
  ELSE
    abs1 = -(delxa(i)-px)
  END IF
!       y2
  IF (delya(j) - py .GE. 0.) THEN
    abs2 = delya(j) - py
  ELSE
    abs2 = -(delya(j)-py)
  END IF
!
!       z1
!
!       x1
!       x2
  IF (delxa(i) - px .GE. 0.) THEN
    abs3 = delxa(i) - px
  ELSE
    abs3 = -(delxa(i)-px)
  END IF
!       y1
!
!       x1
!       x2
  IF (delxa(i) - px .GE. 0.) THEN
    abs4 = delxa(i) - px
  ELSE
    abs4 = -(delxa(i)-px)
  END IF
!       y2
  IF (delya(j) - py .GE. 0.) THEN
    abs5 = delya(j) - py
  ELSE
    abs5 = -(delya(j)-py)
  END IF
!
!       z2
  IF (delza(k) - pz .GE. 0.) THEN
    abs6 = delza(k) - pz
  ELSE
    abs6 = -(delza(k)-pz)
  END IF
!
  arg1 = (delz(k)+delz(nk))*0.5d0
!
  CALL LIN_INTERPOL_AD0(d_a2, d_a2_ad, d_b2, d_b2_ad, abs6, arg1, &
&                 interpolatelin_adv)
  arg1 = (dely(j)+dely(nj))*0.5d0
  CALL LIN_INTERPOL_AD0(d_a1, d_a1_ad, d_b1, d_b1_ad, abs5, arg1, &
&                 d_b2_ad)
  arg1 = (delx(i)+delx(ni))*0.5d0
  CALL LIN_INTERPOL_AD0(d_a0, d_a0_ad, d_b0, d_b0_ad, abs4, arg1, &
&                 d_b1_ad)
  vals_ad(ni, nj, nk) = vals_ad(ni, nj, nk) + d_b0_ad
  vals_ad(i, nj, nk) = vals_ad(i, nj, nk) + d_a0_ad
  arg1 = (delx(i)+delx(ni))*0.5d0
  CALL LIN_INTERPOL_AD0(d_a0, d_a0_ad, d_b0, d_b0_ad, abs3, arg1, &
&                 d_a1_ad)
  vals_ad(ni, j, nk) = vals_ad(ni, j, nk) + d_b0_ad
  vals_ad(i, j, nk) = vals_ad(i, j, nk) + d_a0_ad
  arg1 = (dely(j)+dely(nj))*0.5d0
  CALL LIN_INTERPOL_AD0(d_a1, d_a1_ad, d_b1, d_b1_ad, abs2, arg1, &
&                 d_a2_ad)
  arg1 = (delx(i)+delx(ni))*0.5d0
  CALL LIN_INTERPOL_AD0(d_a0, d_a0_ad, d_b0, d_b0_ad, abs1, arg1, &
&                 d_b1_ad)
  vals_ad(ni, nj, k) = vals_ad(ni, nj, k) + d_b0_ad
  vals_ad(i, nj, k) = vals_ad(i, nj, k) + d_a0_ad
  arg1 = (delx(i)+delx(ni))*0.5d0
  CALL LIN_INTERPOL_AD0(d_a0, d_a0_ad, d_b0, d_b0_ad, abs0, arg1, &
&                 d_a1_ad)
  vals_ad(ni, j, k) = vals_ad(ni, j, k) + d_b0_ad
  vals_ad(i, j, k) = vals_ad(i, j, k) + d_a0_ad
END SUBROUTINE INTERPOLATELIN_AD

