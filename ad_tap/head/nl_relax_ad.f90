!        Generated by TAPENADE     (INRIA, Ecuador team)
!  tapenade 3.x
!
!  Differentiation of nl_relax in reverse (adjoint) mode (with options noISIZE i8):
!   gradient     of useful results: relax r
!   with respect to varying inputs: r relaxold rold
! MIT License
!
! Copyright (c) 2020 SHEMAT-Suite
!
! Permission is hereby granted, free of charge, to any person obtaining a copy
! of this software and associated documentation files (the "Software"), to deal
! in the Software without restriction, including without limitation the rights
! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
! copies of the Software, and to permit persons to whom the Software is
! furnished to do so, subject to the following conditions:
!
! The above copyright notice and this permission notice shall be included in all
! copies or substantial portions of the Software.
!
! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
! SOFTWARE.
!>    @brief adaptive relaxation parameter
!>    @param[in] iter iteration counter
!>    @param[in] r <description>
!>    @param[in] rold <description>
!>    @param[in] emax <description>
!>    @param[out] relax current relaxation value
!>    @param[in,out] relaxold old relaxation value
!>    @param[in] ismpl local sample index
!>    @details
!> calculate adaptive relaxation parameter\n
!> see Cooley (1983), WRR 19(5), 1271-1285\n
SUBROUTINE NL_RELAX_AD(iter, r, r_ad, rold, rold_ad, emax, relax, &
& relax_ad, relaxold, relaxold_ad, ismpl)
  USE MOD_GENRL
  USE MOD_GENRLC
  USE MOD_LINFOS
  IMPLICIT NONE
  INTEGER :: ismpl
  INTEGER :: iter
  DOUBLE PRECISION :: r, rold, emax, relax, relaxold, s
  DOUBLE PRECISION :: r_ad, rold_ad, relax_ad, relaxold_ad, s_ad
  INTRINSIC ABS
  INTRINSIC MAX
  INTRINSIC MIN
  DOUBLE PRECISION :: y1
  DOUBLE PRECISION :: y1_ad
  DOUBLE PRECISION :: abs0
  DOUBLE PRECISION :: abs0_ad
  DOUBLE PRECISION :: abs1
  DOUBLE PRECISION :: abs1_ad
  DOUBLE PRECISION :: abs2
  DOUBLE PRECISION :: abs3
  DOUBLE PRECISION :: abs3_ad
  DOUBLE PRECISION :: temporary_ad
  DOUBLE PRECISION :: temporary_ad0
  INTEGER :: branch
!  step 1
  IF (iter .EQ. 1) THEN
    s = 1.0d0
    CALL PUSHCONTROL1B(0)
  ELSE
    s = r/(relaxold*rold)
    CALL PUSHCONTROL1B(1)
  END IF
! step 2
  IF (s .GE. -1.d0) THEN
    IF (s .GE. 0.) THEN
      abs0 = s
      CALL PUSHCONTROL1B(0)
    ELSE
      abs0 = -s
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL8(relax)
    relax = (3.d0+s)/(3.d0+abs0)
    CALL PUSHCONTROL1B(1)
  ELSE
    IF (s .GE. 0.) THEN
      abs1 = s
      CALL PUSHCONTROL1B(0)
    ELSE
      abs1 = -s
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL8(relax)
    relax = 0.5d0/abs1
    CALL PUSHCONTROL1B(0)
  END IF
  IF (r .GE. 0.) THEN
    abs2 = r
  ELSE
    abs2 = -r
  END IF
! step 3
  IF (relax*abs2 .GT. emax) THEN
    IF (r .GE. 0.) THEN
      abs3 = r
      CALL PUSHCONTROL1B(0)
    ELSE
      abs3 = -r
      CALL PUSHCONTROL1B(1)
    END IF
    relax = emax/abs3
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  IF (0.05d0 .LT. relax) THEN
    y1 = relax
    CALL PUSHCONTROL1B(0)
  ELSE
    y1 = 0.05d0
    CALL PUSHCONTROL1B(1)
  END IF
  IF (1.d0 .GT. y1) THEN
    y1_ad = relax_ad
  ELSE
    y1_ad = 0.D0
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    relax_ad = y1_ad
  ELSE
    relax_ad = 0.D0
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    abs3_ad = -(emax*relax_ad/abs3**2)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      r_ad = r_ad + abs3_ad
    ELSE
      r_ad = r_ad - abs3_ad
    END IF
    relax_ad = 0.D0
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    CALL POPREAL8(relax)
    abs1_ad = -(0.5d0*relax_ad/abs1**2)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      s_ad = abs1_ad
    ELSE
      s_ad = -abs1_ad
    END IF
  ELSE
    CALL POPREAL8(relax)
    temporary_ad0 = relax_ad/(abs0+3.d0)
    s_ad = temporary_ad0
    abs0_ad = -((s+3.d0)*temporary_ad0/(abs0+3.d0))
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      s_ad = s_ad + abs0_ad
    ELSE
      s_ad = s_ad - abs0_ad
    END IF
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    relaxold_ad = 0.D0
    rold_ad = 0.D0
  ELSE
    temporary_ad = s_ad/(relaxold*rold)
    r_ad = r_ad + temporary_ad
    temporary_ad0 = -(r*temporary_ad/(relaxold*rold))
    relaxold_ad = rold*temporary_ad0
    rold_ad = relaxold*temporary_ad0
  END IF
END SUBROUTINE NL_RELAX_AD

