!        Generated by TAPENADE     (INRIA, Ecuador team)
!  tapenade 3.x
!
!  Differentiation of omp_mvp in reverse (adjoint) mode (with options noISIZE i8):
!   gradient     of useful results: d e f g s as a b c
!   with respect to varying inputs: d e f g s as a b c
! MIT License
!
! Copyright (c) 2020 SHEMAT-Suite
!
! Permission is hereby granted, free of charge, to any person obtaining a copy
! of this software and associated documentation files (the "Software"), to deal
! in the Software without restriction, including without limitation the rights
! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
! copies of the Software, and to permit persons to whom the Software is
! furnished to do so, subject to the following conditions:
!
! The above copyright notice and this permission notice shall be included in all
! copies or substantial portions of the Software.
!
! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
! SOFTWARE.
!>    @brief apply 7point-star matrix multiply [as]:=[M]x[s], (OpenMP version)
!>    @param[in] N_I lengths of I dimension of local matrix [M]
!>    @param[in] N_J lengths of J dimension of local matrix [M]
!>    @param[in] N_K lengths of K dimension of local matrix [M]
!>    @param[in] s vector [s]
!>    @param[out] as vector [as]
!>    @param[in] A 1. diagonal of the system matrix [M]
!>    @param[in] B 2. diagonal of the system matrix [M]
!>    @param[in] C 3. diagonal of the system matrix [M]
!>    @param[in] D 4. (main) diagonal of the system matrix [M]
!>    @param[in] E 5. diagonal of the system matrix [M]
!>    @param[in] F 6. diagonal of the system matrix [M]
!>    @param[in] G 7. diagonal of the system matrix [M]
!>    @details
!>    OpenMP parallelised, general version - no special blocking\n
!>    apply 7point-star matrix multiply\n
!>    compute [as]:=[M]x[s], [s],[as],[M] given in 3-D-structure\n
!>    Data-Cube :\n
!>    @image html cube.png
!       k     * * * *
!     /     *     * *
!    0 -j * * * *   *
!    |    *     *   *
!    i    *     * *
!         * * * *
SUBROUTINE OMP_MVP_AD(n_i, n_j, n_k, s, s_ad, as, as_ad, a, a_ad, b, &
& b_ad, c, c_ad, d, d_ad, e, e_ad, f, f_ad, g, g_ad)
  USE MOD_OMP_TOOLS
  USE MOD_BLOCKING_SIZE
  IMPLICIT NONE
  INCLUDE 'OMP_TOOLS.inc'
  INTEGER :: n_i, n_j, n_k
!      use mod_blocking_size
  DOUBLE PRECISION :: s(*), as(*)
  DOUBLE PRECISION :: s_ad(*), as_ad(*)
  DOUBLE PRECISION :: a(*), b(*), c(*), d(*), e(*), f(*), g(*)
  DOUBLE PRECISION :: a_ad(*), b_ad(*), c_ad(*), d_ad(*), e_ad(*), f_ad(&
& *), g_ad(*)
  INTEGER :: pim, pip, pjm, pjp, pkm, pkp
  INTEGER :: aim, aip, ajm, ajp, akm, akp
  INTEGER :: bm, pm, pmb, am, pmmax
!     thread stuff
  INTEGER :: tpos, tanz
  INTRINSIC INT
  INTRINSIC MIN
  INTRINSIC MAX
  INTEGER :: branch
  INTEGER :: ad_count
  INTEGER :: i
  INTEGER :: x2
  INTEGER :: x1
  tpos = 1
  tanz = n_i*n_j*n_k
  bm = tpos + tanz - 1
  pm = tpos
  pmmax = n_i*n_j*n_k + 1
  x1 = pm + INT(bl_size/bldiv_mvp)
  IF (x1 .GT. bm + 1) THEN
    pmb = bm + 1
  ELSE
    pmb = x1
  END IF
  am = pmb - pm
  IF (pm - 1 .LT. 1) THEN
    pim = 1
  ELSE
    pim = pm - 1
  END IF
  aim = pmb - 1 - pim
  IF (pmb + 1 .GT. pmmax) THEN
    pip = pmmax
  ELSE
    pip = pmb + 1
  END IF
  aip = pip - 1 - pm
  IF (pm - n_i .LT. 1) THEN
    pjm = 1
  ELSE
    pjm = pm - n_i
  END IF
  ajm = pmb - n_i - pjm
  IF (pmb + n_i .GT. pmmax) THEN
    pjp = pmmax
  ELSE
    pjp = pmb + n_i
  END IF
  ajp = pjp - n_i - pm
  IF (pm - n_i*n_j .LT. 1) THEN
    pkm = 1
  ELSE
    pkm = pm - n_i*n_j
  END IF
  akm = pmb - n_i*n_j - pkm
  IF (pmb + n_i*n_j .GT. pmmax) THEN
    pkp = pmmax
  ELSE
    pkp = pmb + n_i*n_j
  END IF
  akp = pkp - n_i*n_j - pm
  ad_count = 1
!AW C$OMP barrier
 100 IF (n_i .GT. 1) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  IF (n_j .GT. 1) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  IF (n_k .GT. 1) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  IF (n_i .GT. 1) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  IF (n_j .GT. 1) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  IF (n_k .GT. 1) THEN
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
!aw      write(*,*)' ',OMP_GET_HIS_THREAD_NUM(),pm,pm+am-1,pmb-1
!aw      write(*,*)'iC',OMP_GET_HIS_THREAD_NUM(),pim+1,-1,aim
!aw      write(*,*)'iE',OMP_GET_HIS_THREAD_NUM(),pm,1,aip
!aw      write(*,*)'jB',OMP_GET_HIS_THREAD_NUM(),pjm+N_I,-N_I,ajm
!aw      write(*,*)'jF',OMP_GET_HIS_THREAD_NUM(),pm,N_I,ajp
!aw      write(*,*)'kA',OMP_GET_HIS_THREAD_NUM(),pkm+N_I*N_J,-N_I*N_J,akm
!aw      write(*,*)'kG',OMP_GET_HIS_THREAD_NUM(),pm,N_I*N_J,akp
  CALL PUSHINTEGER8(pm)
  pm = pmb
  x2 = pm + INT(bl_size/bldiv_mvp)
  IF (x2 .GT. bm + 1) THEN
    pmb = bm + 1
  ELSE
    pmb = x2
  END IF
  CALL PUSHINTEGER8(am)
  am = pmb - pm
  IF (pm - 1 .LT. 1) THEN
    CALL PUSHINTEGER8(pim)
    pim = 1
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHINTEGER8(pim)
    pim = pm - 1
    CALL PUSHCONTROL1B(1)
  END IF
  CALL PUSHINTEGER8(aim)
  aim = pmb - 1 - pim
  IF (pmb + 1 .GT. pmmax) THEN
    pip = pmmax
  ELSE
    pip = pmb + 1
  END IF
  CALL PUSHINTEGER8(aip)
  aip = pip - 1 - pm
  IF (pm - n_i .LT. 1) THEN
    CALL PUSHINTEGER8(pjm)
    pjm = 1
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHINTEGER8(pjm)
    pjm = pm - n_i
    CALL PUSHCONTROL1B(1)
  END IF
  CALL PUSHINTEGER8(ajm)
  ajm = pmb - n_i - pjm
  IF (pmb + n_i .GT. pmmax) THEN
    pjp = pmmax
  ELSE
    pjp = pmb + n_i
  END IF
  CALL PUSHINTEGER8(ajp)
  ajp = pjp - n_i - pm
  IF (pm - n_i*n_j .LT. 1) THEN
    CALL PUSHINTEGER8(pkm)
    pkm = 1
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHINTEGER8(pkm)
    pkm = pm - n_i*n_j
    CALL PUSHCONTROL1B(1)
  END IF
  CALL PUSHINTEGER8(akm)
  akm = pmb - n_i*n_j - pkm
  IF (pmb + n_i*n_j .GT. pmmax) THEN
    pkp = pmmax
  ELSE
    pkp = pmb + n_i*n_j
  END IF
  CALL PUSHINTEGER8(akp)
  akp = pkp - n_i*n_j - pm
  IF (am .GT. 0) THEN
    ad_count = ad_count + 1
    GOTO 100
  END IF
  CALL PUSHINTEGER8(ad_count)
  CALL POPINTEGER8(ad_count)
  DO i=1,ad_count
    CALL POPINTEGER8(akp)
    CALL POPINTEGER8(akm)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPINTEGER8(pkm)
    ELSE
      CALL POPINTEGER8(pkm)
    END IF
    CALL POPINTEGER8(ajp)
    CALL POPINTEGER8(ajm)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPINTEGER8(pjm)
    ELSE
      CALL POPINTEGER8(pjm)
    END IF
    CALL POPINTEGER8(aip)
    CALL POPINTEGER8(aim)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPINTEGER8(pim)
    ELSE
      CALL POPINTEGER8(pim)
    END IF
    CALL POPINTEGER8(am)
    CALL POPINTEGER8(pm)
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) CALL DXYPZ_AD(akm, s(pkm), s_ad(pkm), a(pkm+n_i*&
&                              n_j), a_ad(pkm+n_i*n_j), as(pkm+n_i*n_j)&
&                              , as_ad(pkm+n_i*n_j))
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) CALL DXYPZ_AD(ajm, s(pjm), s_ad(pjm), b(pjm+n_i)&
&                              , b_ad(pjm+n_i), as(pjm+n_i), as_ad(pjm+&
&                              n_i))
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) CALL DXYPZ_AD(aim, s(pim), s_ad(pim), c(pim+1), &
&                              c_ad(pim+1), as(pim+1), as_ad(pim+1))
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) CALL DXYPZ_AD(akp, s(pm+n_i*n_j), s_ad(pm+n_i*n_j&
&                              ), g(pm), g_ad(pm), as(pm), as_ad(pm))
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) CALL DXYPZ_AD(ajp, s(pm+n_i), s_ad(pm+n_i), f(pm)&
&                              , f_ad(pm), as(pm), as_ad(pm))
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) CALL DXYPZ_AD(aip, s(pm+1), s_ad(pm+1), e(pm), &
&                              e_ad(pm), as(pm), as_ad(pm))
    CALL DXYZ_AD(am, s(pm), s_ad(pm), d(pm), d_ad(pm), as(pm), as_ad(pm)&
&         )
  END DO
END SUBROUTINE OMP_MVP_AD

