!        Generated by TAPENADE     (INRIA, Ecuador team)
!  tapenade 3.x
!
!  Differentiation of interpolatelin in forward (tangent) mode:
!   variations   of useful results: interpolatelin
!   with respect to varying inputs: vals
! MIT License
!
! Copyright (c) 2020 SHEMAT-Suite
!
! Permission is hereby granted, free of charge, to any person obtaining a copy
! of this software and associated documentation files (the "Software"), to deal
! in the Software without restriction, including without limitation the rights
! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
! copies of the Software, and to permit persons to whom the Software is
! furnished to do so, subject to the following conditions:
!
! The above copyright notice and this permission notice shall be included in all
! copies or substantial portions of the Software.
!
! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
! SOFTWARE.
!>    @brief inter cell interpolation
!>    @param[in] I0 i-dimension
!>    @param[in] J0 j-dimension
!>    @param[in] K0 k-dimension
!>    @param[in] i cell index, direction I0
!>    @param[in] j cell index, direction J0
!>    @param[in] k cell index, direction K0
!>    @param[in] vals state variables (values)
!>    @param[in] px I0-direction interpolation position
!>    @param[in] py J0-direction interpolation position
!>    @param[in] pz K0-direction interpolation position
!>    @param[in] delx I0-direction cell dimensions (delta size)
!>    @param[in] dely J0-direction cell dimensions (delta size)
!>    @param[in] delz K0-direction cell dimensions (delta size)
!>    @param[in] delxa I0-direction absolute cell positions
!>    @param[in] delya J0-direction absolute cell positions
!>    @param[in] delza K0-direction absolute cell positions
!>    @return interpolated value
DOUBLE PRECISION FUNCTION g_INTERPOLATELIN(i0, j0, k0, i, j, k, vals, &
& g_vals, px, py, pz, delx, dely, delz, delxa, delya, delza, &
& interpolatelin)
  IMPLICIT NONE
!       i,j,k cell index (first corner - 3D)
  INTEGER :: i, j, k, i0, j0, k0
!       neighbours i,j,k cell index (second corner - 3D)
  INTEGER :: ni, nj, nk
!       state variables (values)
  DOUBLE PRECISION :: vals(i0, j0, k0)
  DOUBLE PRECISION :: g_vals(i0, j0, k0)
!       x,y,z cell dimensions (delta size)
  DOUBLE PRECISION :: delx(i0), dely(j0), delz(k0)
!       x,y,z absolute cell position
  DOUBLE PRECISION :: delxa(i0), delya(j0), delza(k0)
!       x,y,z interpolation position
  DOUBLE PRECISION :: px, py, pz
!
  DOUBLE PRECISION :: d_a0, d_b0, d_a1, d_b1, d_a2, d_b2
  DOUBLE PRECISION :: g_d_a0, g_d_b0, g_d_a1, g_d_b1, g_d_a2, &
& g_d_b2
  EXTERNAL LIN_INTERPOL
  EXTERNAL g_LIN_INTERPOL
  DOUBLE PRECISION :: LIN_INTERPOL
  DOUBLE PRECISION :: g_LIN_INTERPOL
  INTRINSIC MIN, MAX, ABS
  INTEGER :: x1
  INTEGER :: x2
  INTEGER :: x3
  DOUBLE PRECISION :: abs0
  DOUBLE PRECISION :: abs1
  DOUBLE PRECISION :: abs2
  DOUBLE PRECISION :: abs3
  DOUBLE PRECISION :: abs4
  DOUBLE PRECISION :: abs5
  DOUBLE PRECISION :: abs6
  DOUBLE PRECISION :: interpolatelin
!       get neighbour i-index
  ni = i + 1
  IF (px .LT. delxa(i)) ni = i - 1
  IF (ni .LT. 1) THEN
    x1 = 1
  ELSE
    x1 = ni
  END IF
  IF (x1 .GT. i0) THEN
    ni = i0
  ELSE
    ni = x1
  END IF
!       get neighbour j-index
  nj = j + 1
  IF (py .LT. delya(j)) nj = j - 1
  IF (nj .LT. 1) THEN
    x2 = 1
  ELSE
    x2 = nj
  END IF
  IF (x2 .GT. j0) THEN
    nj = j0
  ELSE
    nj = x2
  END IF
!       get neighbour k-index
  nk = k + 1
  IF (pz .LT. delza(k)) nk = k - 1
  IF (nk .LT. 1) THEN
    x3 = 1
  ELSE
    x3 = nk
  END IF
  IF (x3 .GT. k0) THEN
    nk = k0
  ELSE
    nk = x3
  END IF
!
!       x1
  g_d_a0 = g_vals(i, j, k)
  d_a0 = vals(i, j, k)
!       x2
  g_d_b0 = g_vals(ni, j, k)
  d_b0 = vals(ni, j, k)
  IF (delxa(i) - px .GE. 0.) THEN
    abs0 = delxa(i) - px
  ELSE
    abs0 = -(delxa(i)-px)
  END IF
!       y1
  g_d_a1 = g_LIN_INTERPOL(d_a0, g_d_a0, d_b0, g_d_b0, abs0, (&
&   delx(i)+delx(ni))*0.5d0, d_a1)
!
!       x1
  g_d_a0 = g_vals(i, nj, k)
  d_a0 = vals(i, nj, k)
!       x2
  g_d_b0 = g_vals(ni, nj, k)
  d_b0 = vals(ni, nj, k)
  IF (delxa(i) - px .GE. 0.) THEN
    abs1 = delxa(i) - px
  ELSE
    abs1 = -(delxa(i)-px)
  END IF
!       y2
  g_d_b1 = g_LIN_INTERPOL(d_a0, g_d_a0, d_b0, g_d_b0, abs1, (&
&   delx(i)+delx(ni))*0.5d0, d_b1)
  IF (delya(j) - py .GE. 0.) THEN
    abs2 = delya(j) - py
  ELSE
    abs2 = -(delya(j)-py)
  END IF
!
!       z1
  g_d_a2 = g_LIN_INTERPOL(d_a1, g_d_a1, d_b1, g_d_b1, abs2, (&
&   dely(j)+dely(nj))*0.5d0, d_a2)
!
!       x1
  g_d_a0 = g_vals(i, j, nk)
  d_a0 = vals(i, j, nk)
!       x2
  g_d_b0 = g_vals(ni, j, nk)
  d_b0 = vals(ni, j, nk)
  IF (delxa(i) - px .GE. 0.) THEN
    abs3 = delxa(i) - px
  ELSE
    abs3 = -(delxa(i)-px)
  END IF
!       y1
  g_d_a1 = g_LIN_INTERPOL(d_a0, g_d_a0, d_b0, g_d_b0, abs3, (&
&   delx(i)+delx(ni))*0.5d0, d_a1)
!
!       x1
  g_d_a0 = g_vals(i, nj, nk)
  d_a0 = vals(i, nj, nk)
!       x2
  g_d_b0 = g_vals(ni, nj, nk)
  d_b0 = vals(ni, nj, nk)
  IF (delxa(i) - px .GE. 0.) THEN
    abs4 = delxa(i) - px
  ELSE
    abs4 = -(delxa(i)-px)
  END IF
!       y2
  g_d_b1 = g_LIN_INTERPOL(d_a0, g_d_a0, d_b0, g_d_b0, abs4, (&
&   delx(i)+delx(ni))*0.5d0, d_b1)
  IF (delya(j) - py .GE. 0.) THEN
    abs5 = delya(j) - py
  ELSE
    abs5 = -(delya(j)-py)
  END IF
!
!       z2
  g_d_b2 = g_LIN_INTERPOL(d_a1, g_d_a1, d_b1, g_d_b1, abs5, (&
&   dely(j)+dely(nj))*0.5d0, d_b2)
  IF (delza(k) - pz .GE. 0.) THEN
    abs6 = delza(k) - pz
  ELSE
    abs6 = -(delza(k)-pz)
  END IF
!
  g_interpolatelin = g_LIN_INTERPOL(d_a2, g_d_a2, d_b2, g_d_b2, &
&   abs6, (delz(k)+delz(nk))*0.5d0, interpolatelin)
!
  RETURN
END FUNCTION g_INTERPOLATELIN

