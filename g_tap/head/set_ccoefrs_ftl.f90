!        Generated by TAPENADE     (INRIA, Ecuador team)
!  tapenade 3.x
!
!  Differentiation of set_ccoefrs in forward (tangent) mode:
!   variations   of useful results: *d *w *x
!   with respect to varying inputs: *d *e *f *concold *g *w *x
!                *propunit *a *b *c
!   Plus diff mem management of: d:in e:in f:in concold:in g:in
!                w:in x:in propunit:in simtime:in a:in b:in c:in
!>    @brief coefficents for the transport equation (here only the right side)
!>    @param[in] spec species index
!>    @param[in] ismpl local sample index
!>    @details
!> calculate coefficents for the transport equation\n
!> coefficients are stored as vectors in the diagonals a-g (d center) and rhs in w.\n
SUBROUTINE g_SET_CCOEFRS(spec, ismpl)
  USE ARRAYS

  USE g_ARRAYS

  USE MOD_GENRL
  USE MOD_GENRLC
  USE MOD_CONC
  USE MOD_TIME

  USE g_MOD_TIME

  USE MOD_LINFOS
  IMPLICIT NONE
  INTEGER :: ismpl
  INTEGER :: i, j, k
! DOUBLE PRECISION rhoceff
  DOUBLE PRECISION :: deltt
! INTEGER c1, c2, c3, c4
  INTEGER :: spec
  EXTERNAL DELTAT, POR
  EXTERNAL g_POR
  DOUBLE PRECISION :: DELTAT, POR
  DOUBLE PRECISION :: g_POR
  EXTERNAL DUMMY
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: g_result1
  DOUBLE PRECISION :: temp0
  deltt = DELTAT(simtime(ismpl), ismpl)
! - - rhs: sources, also terms for transient calculations - - - - - - - - -
  IF (transient .AND. tr_switch(ismpl)) THEN
! - - - - - - - transient - - - - - - - - - - - - - - - - - - - - - - - - -
    CALL g_OMP_MVP(i0, j0, k0, concold(1, spec, cgen_time, ismpl), &
&              g_concold(1, spec, cgen_time, ismpl), x(1, 1, 1, ismpl)&
&              , g_x(1, 1, 1, ismpl), a(1, 1, 1, ismpl), g_a(1, 1, 1&
&              , ismpl), b(1, 1, 1, ismpl), g_b(1, 1, 1, ismpl), c(1, &
&              1, 1, ismpl), g_c(1, 1, 1, ismpl), d(1, 1, 1, ismpl), &
&              g_d(1, 1, 1, ismpl), e(1, 1, 1, ismpl), g_e(1, 1, 1, &
&              ismpl), f(1, 1, 1, ismpl), g_f(1, 1, 1, ismpl), g(1, 1&
&              , 1, ismpl), g_g(1, 1, 1, ismpl))
!$OMP    do schedule(static) collapse(3)
    DO k=1,k0
      DO j=1,j0
        DO i=1,i0
          g_result1 = g_POR(i, j, k, ismpl, result1)
          g_d(i, j, k, ismpl) = g_d(i, j, k, ismpl) - g_result1/(&
&           deltt*thetac)
          d(i, j, k, ismpl) = d(i, j, k, ismpl) - result1/(deltt*thetac)
          g_result1 = g_POR(i, j, k, ismpl, result1)
          temp0 = concold(i+(j-1)*i0+(k-1)*i0*j0, spec, cgen_time, ismpl&
&           )
          g_w(i, j, k, ismpl) = g_w(i, j, k, ismpl) - result1*&
&           g_concold(i+(j-1)*i0+(k-1)*i0*j0, spec, cgen_time, ismpl)/&
&           deltt - temp0*g_result1/deltt - (1.d0-thetac)*g_x(i, j, &
&           k, ismpl)
          w(i, j, k, ismpl) = w(i, j, k, ismpl) - temp0*(result1/deltt) &
&           - (1.d0-thetac)*x(i, j, k, ismpl)
          g_w(i, j, k, ismpl) = g_w(i, j, k, ismpl)/thetac
          w(i, j, k, ismpl) = w(i, j, k, ismpl)/thetac
        END DO
      END DO
    END DO
!$OMP    end do nowait
  END IF
! - - - - - - - - steady state - - - - - - - - - - - - - - - - - - - - - 
! C$OMP    do schedule(static) collapse(3)
!          do k=1,k0
!             do j=1,j0
!                do i=1,i0
!                   w(i,j,k,ismpl) = w(i,j,k,ismpl)
!                     - hs(i,j,k,spec,ismpl)
!                end do
!             end do
!          end do
! C$OMP    end do nowait
  RETURN
END SUBROUTINE g_SET_CCOEFRS

