!        Generated by TAPENADE     (INRIA, Ecuador team)
!  tapenade 3.x
!
!  Differentiation of nl_relax in forward (tangent) mode:
!   variations   of useful results: relax
!   with respect to varying inputs: r relaxold rold
! MIT License
!
! Copyright (c) 2020 SHEMAT-Suite
!
! Permission is hereby granted, free of charge, to any person obtaining a copy
! of this software and associated documentation files (the "Software"), to deal
! in the Software without restriction, including without limitation the rights
! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
! copies of the Software, and to permit persons to whom the Software is
! furnished to do so, subject to the following conditions:
!
! The above copyright notice and this permission notice shall be included in all
! copies or substantial portions of the Software.
!
! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
! SOFTWARE.
!>    @brief adaptive relaxation parameter
!>    @param[in] iter iteration counter
!>    @param[in] r <description>
!>    @param[in] rold <description>
!>    @param[in] emax <description>
!>    @param[out] relax current relaxation value
!>    @param[in,out] relaxold old relaxation value
!>    @param[in] ismpl local sample index
!>    @details
!> calculate adaptive relaxation parameter\n
!> see Cooley (1983), WRR 19(5), 1271-1285\n
SUBROUTINE g_NL_RELAX(iter, r, g_r, rold, g_rold, emax, relax, &
& g_relax, relaxold, g_relaxold, ismpl)
  USE MOD_GENRL
  USE MOD_GENRLC
  USE MOD_LINFOS
  IMPLICIT NONE
  INTEGER :: ismpl
  INTEGER :: iter
  DOUBLE PRECISION :: r, rold, emax, relax, relaxold, s
  DOUBLE PRECISION :: g_r, g_rold, g_relax, g_relaxold, g_s
  INTRINSIC ABS
  INTRINSIC MAX
  INTRINSIC MIN
  DOUBLE PRECISION :: y1
  DOUBLE PRECISION :: g_y1
  DOUBLE PRECISION :: abs0
  DOUBLE PRECISION :: g_abs0
  DOUBLE PRECISION :: abs1
  DOUBLE PRECISION :: g_abs1
  DOUBLE PRECISION :: abs2
  DOUBLE PRECISION :: abs3
  DOUBLE PRECISION :: g_abs3
  DOUBLE PRECISION :: temporary
!  step 1
  IF (iter .EQ. 1) THEN
    s = 1.0d0
    g_s = 0.D0
  ELSE
    temporary = r/(relaxold*rold)
    g_s = (g_r-temporary*(rold*g_relaxold+relaxold*g_rold))/(relaxold&
&     *rold)
    s = temporary
  END IF
  WRITE(*, *) 'r, rold =', r, rold, '    s= ', s
! step 2
  IF (s .GE. -1.d0) THEN
    IF (s .GE. 0.) THEN
      g_abs0 = g_s
      abs0 = s
    ELSE
      g_abs0 = -g_s
      abs0 = -s
    END IF
    temporary = (s+3.d0)/(abs0+3.d0)
    g_relax = (g_s-temporary*g_abs0)/(abs0+3.d0)
    relax = temporary
  ELSE
    IF (s .GE. 0.) THEN
      g_abs1 = g_s
      abs1 = s
    ELSE
      g_abs1 = -g_s
      abs1 = -s
    END IF
    g_relax = -(0.5d0*g_abs1/abs1**2)
    relax = 0.5d0/abs1
  END IF
  IF (r .GE. 0.) THEN
    abs2 = r
  ELSE
    abs2 = -r
  END IF
! step 3
  IF (relax*abs2 .GT. emax) THEN
    IF (r .GE. 0.) THEN
      g_abs3 = g_r
      abs3 = r
    ELSE
      g_abs3 = -g_r
      abs3 = -r
    END IF
    g_relax = -(emax*g_abs3/abs3**2)
    relax = emax/abs3
  END IF
  IF (0.05d0 .LT. relax) THEN
    g_y1 = g_relax
    y1 = relax
  ELSE
    y1 = 0.05d0
    g_y1 = 0.D0
  END IF
  IF (1.d0 .GT. y1) THEN
    g_relax = g_y1
    relax = y1
  ELSE
    relax = 1.d0
    g_relax = 0.D0
  END IF
  WRITE(*, *) '**** relax= ', relax, ' (', relaxold, ')'
!
  relaxold = relax
!
  IF (linfos(3) .GE. 1) WRITE(*, '(1a,1e10.3)') ' relaxation factor: ', &
&                       relax
!
  RETURN
END SUBROUTINE g_NL_RELAX

