!        Generated by TAPENADE     (INRIA, Ecuador team)
!  tapenade 3.x
!
!  Differentiation of omp_mvp in forward (tangent) mode:
!   variations   of useful results: as
!   with respect to varying inputs: d e f g s as a b c
! MIT License
!
! Copyright (c) 2020 SHEMAT-Suite
!
! Permission is hereby granted, free of charge, to any person obtaining a copy
! of this software and associated documentation files (the "Software"), to deal
! in the Software without restriction, including without limitation the rights
! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
! copies of the Software, and to permit persons to whom the Software is
! furnished to do so, subject to the following conditions:
!
! The above copyright notice and this permission notice shall be included in all
! copies or substantial portions of the Software.
!
! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
! SOFTWARE.
!>    @brief apply 7point-star matrix multiply [as]:=[M]x[s], (OpenMP version)
!>    @param[in] N_I lengths of I dimension of local matrix [M]
!>    @param[in] N_J lengths of J dimension of local matrix [M]
!>    @param[in] N_K lengths of K dimension of local matrix [M]
!>    @param[in] s vector [s]
!>    @param[out] as vector [as]
!>    @param[in] A 1. diagonal of the system matrix [M]
!>    @param[in] B 2. diagonal of the system matrix [M]
!>    @param[in] C 3. diagonal of the system matrix [M]
!>    @param[in] D 4. (main) diagonal of the system matrix [M]
!>    @param[in] E 5. diagonal of the system matrix [M]
!>    @param[in] F 6. diagonal of the system matrix [M]
!>    @param[in] G 7. diagonal of the system matrix [M]
!>    @details
!>    OpenMP parallelised, general version - no special blocking\n
!>    apply 7point-star matrix multiply\n
!>    compute [as]:=[M]x[s], [s],[as],[M] given in 3-D-structure\n
!>    Data-Cube :\n
!>    @image html cube.png
!       k     * * * *
!     /     *     * *
!    0 -j * * * *   *
!    |    *     *   *
!    i    *     * *
!         * * * *
SUBROUTINE g_OMP_MVP(n_i, n_j, n_k, s, g_s, as, g_as, a, g_a, b&
& , g_b, c, g_c, d, g_d, e, g_e, f, g_f, g, g_g)
  USE MOD_OMP_TOOLS
  USE MOD_BLOCKING_SIZE
  IMPLICIT NONE
  INCLUDE 'OMP_TOOLS.inc'
  INTEGER :: n_i, n_j, n_k
!      use mod_blocking_size
  DOUBLE PRECISION :: s(*), as(*)
  DOUBLE PRECISION :: g_s(*), g_as(*)
  DOUBLE PRECISION :: a(*), b(*), c(*), d(*), e(*), f(*), g(*)
  DOUBLE PRECISION :: g_a(*), g_b(*), g_c(*), g_d(*), g_e(*), &
& g_f(*), g_g(*)
  INTEGER :: pim, pip, pjm, pjp, pkm, pkp
  INTEGER :: aim, aip, ajm, ajp, akm, akp
  INTEGER :: bm, pm, pmb, am, pmmax
!     thread stuff
  INTEGER :: tpos, tanz
  EXTERNAL DUMMY
  INTRINSIC INT
  INTRINSIC MIN
  INTRINSIC MAX
  INTEGER :: x2
  INTEGER :: x1
  tpos = 1
  tanz = n_i*n_j*n_k
!$      call OMP_PART(N_I*N_J*N_K,tpos,tanz)
  bm = tpos + tanz - 1
  pm = tpos
  pmmax = n_i*n_j*n_k + 1
  x1 = pm + INT(bl_size/bldiv_mvp)
  IF (x1 .GT. bm + 1) THEN
    pmb = bm + 1
  ELSE
    pmb = x1
  END IF
  am = pmb - pm
  IF (pm - 1 .LT. 1) THEN
    pim = 1
  ELSE
    pim = pm - 1
  END IF
  aim = pmb - 1 - pim
  IF (pmb + 1 .GT. pmmax) THEN
    pip = pmmax
  ELSE
    pip = pmb + 1
  END IF
  aip = pip - 1 - pm
  IF (pm - n_i .LT. 1) THEN
    pjm = 1
  ELSE
    pjm = pm - n_i
  END IF
  ajm = pmb - n_i - pjm
  IF (pmb + n_i .GT. pmmax) THEN
    pjp = pmmax
  ELSE
    pjp = pmb + n_i
  END IF
  ajp = pjp - n_i - pm
  IF (pm - n_i*n_j .LT. 1) THEN
    pkm = 1
  ELSE
    pkm = pm - n_i*n_j
  END IF
  akm = pmb - n_i*n_j - pkm
  IF (pmb + n_i*n_j .GT. pmmax) THEN
    pkp = pmmax
  ELSE
    pkp = pmb + n_i*n_j
  END IF
  akp = pkp - n_i*n_j - pm
 100 CALL g_DXYZ(am, s(pm), g_s(pm), d(pm), g_d(pm), as(pm), &
&            g_as(pm))
!AW C$OMP barrier
  IF (n_i .GT. 1) THEN
    CALL g_DXYPZ(aip, s(pm+1), g_s(pm+1), e(pm), g_e(pm), as(pm), &
&            g_as(pm))
!AW C$OMP barrier
  END IF
  IF (n_j .GT. 1) THEN
    CALL g_DXYPZ(ajp, s(pm+n_i), g_s(pm+n_i), f(pm), g_f(pm), as(&
&            pm), g_as(pm))
!AW C$OMP barrier
  END IF
  IF (n_k .GT. 1) THEN
    CALL g_DXYPZ(akp, s(pm+n_i*n_j), g_s(pm+n_i*n_j), g(pm), g_g(&
&            pm), as(pm), g_as(pm))
!AW C$OMP barrier
  END IF
  IF (n_i .GT. 1) THEN
    CALL g_DXYPZ(aim, s(pim), g_s(pim), c(pim+1), g_c(pim+1), as(&
&            pim+1), g_as(pim+1))
!AW C$OMP barrier
  END IF
  IF (n_j .GT. 1) THEN
    CALL g_DXYPZ(ajm, s(pjm), g_s(pjm), b(pjm+n_i), g_b(pjm+n_i), &
&            as(pjm+n_i), g_as(pjm+n_i))
!AW C$OMP barrier
  END IF
  IF (n_k .GT. 1) THEN
    CALL g_DXYPZ(akm, s(pkm), g_s(pkm), a(pkm+n_i*n_j), g_a(pkm+&
&            n_i*n_j), as(pkm+n_i*n_j), g_as(pkm+n_i*n_j))
!AW C$OMP barrier
  END IF
!aw      write(*,*)' ',OMP_GET_HIS_THREAD_NUM(),pm,pm+am-1,pmb-1
!aw      write(*,*)'iC',OMP_GET_HIS_THREAD_NUM(),pim+1,-1,aim
!aw      write(*,*)'iE',OMP_GET_HIS_THREAD_NUM(),pm,1,aip
!aw      write(*,*)'jB',OMP_GET_HIS_THREAD_NUM(),pjm+N_I,-N_I,ajm
!aw      write(*,*)'jF',OMP_GET_HIS_THREAD_NUM(),pm,N_I,ajp
!aw      write(*,*)'kA',OMP_GET_HIS_THREAD_NUM(),pkm+N_I*N_J,-N_I*N_J,akm
!aw      write(*,*)'kG',OMP_GET_HIS_THREAD_NUM(),pm,N_I*N_J,akp
  pm = pmb
  x2 = pm + INT(bl_size/bldiv_mvp)
  IF (x2 .GT. bm + 1) THEN
    pmb = bm + 1
  ELSE
    pmb = x2
  END IF
  am = pmb - pm
  IF (pm - 1 .LT. 1) THEN
    pim = 1
  ELSE
    pim = pm - 1
  END IF
  aim = pmb - 1 - pim
  IF (pmb + 1 .GT. pmmax) THEN
    pip = pmmax
  ELSE
    pip = pmb + 1
  END IF
  aip = pip - 1 - pm
  IF (pm - n_i .LT. 1) THEN
    pjm = 1
  ELSE
    pjm = pm - n_i
  END IF
  ajm = pmb - n_i - pjm
  IF (pmb + n_i .GT. pmmax) THEN
    pjp = pmmax
  ELSE
    pjp = pmb + n_i
  END IF
  ajp = pjp - n_i - pm
  IF (pm - n_i*n_j .LT. 1) THEN
    pkm = 1
  ELSE
    pkm = pm - n_i*n_j
  END IF
  akm = pmb - n_i*n_j - pkm
  IF (pmb + n_i*n_j .GT. pmmax) THEN
    pkp = pmmax
  ELSE
    pkp = pmb + n_i*n_j
  END IF
  akp = pkp - n_i*n_j - pm
  IF (am .GT. 0) GOTO 100
!$OMP  barrier
!      need barrier here
  RETURN
END SUBROUTINE g_OMP_MVP

