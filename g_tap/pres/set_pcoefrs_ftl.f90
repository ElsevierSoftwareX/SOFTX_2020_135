!        Generated by TAPENADE     (INRIA, Ecuador team)
!  tapenade 3.x
!
!  Differentiation of set_pcoefrs in forward (tangent) mode:
!   variations   of useful results: *d *w *x
!   with respect to varying inputs: *d *e *f *g *temp *w *x *propunit
!                *tsal *presold *pres *a *b *c
!   Plus diff mem management of: d:in e:in f:in g:in temp:in w:in
!                x:in propunit:in tsal:in presold:in pres:in simtime:in
!                a:in b:in c:in
!>    @brief calculate right hand side for the head equation
!>    @param[in] ismpl local sample index
!>    @details
!> calculate right hand side for the head equation\n
!> coefficients are stored as vectors in the diagonals a-g (d center) and rhs in w.\n
SUBROUTINE g_SET_PCOEFRS(ismpl)
  USE ARRAYS

  USE g_ARRAYS

  USE MOD_GENRL
  USE MOD_GENRLC
  USE MOD_FLOW
  USE MOD_TIME

  USE g_MOD_TIME

  USE MOD_LINFOS
  IMPLICIT NONE
  INTEGER :: ismpl
  INTEGER :: i, j, k
  DOUBLE PRECISION :: src, deltf, sijk
  DOUBLE PRECISION :: g_src, g_sijk
  EXTERNAL BUOY, COMPF, COMPM, RHOF, POR, DELTAT, &
&     PSTOR, VISF
  EXTERNAL g_BUOY, g_PSTOR
  DOUBLE PRECISION :: BUOY, COMPF, COMPM, RHOF, POR, &
& DELTAT, PSTOR, VISF
  DOUBLE PRECISION :: g_BUOY, g_PSTOR
  EXTERNAL DUMMY
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: g_result1
  DOUBLE PRECISION :: temp0
  deltf = DELTAT(simtime(ismpl), ismpl)
! rhs: sources
  IF (transient .AND. tr_switch(ismpl)) THEN
! - - - - - - - -  transient - - - - - - - - - - -
    CALL g_OMP_MVP(i0, j0, k0, presold(1, cgen_time, ismpl), &
&              g_presold(1, cgen_time, ismpl), x(1, 1, 1, ismpl), &
&              g_x(1, 1, 1, ismpl), a(1, 1, 1, ismpl), g_a(1, 1, 1, &
&              ismpl), b(1, 1, 1, ismpl), g_b(1, 1, 1, ismpl), c(1, 1&
&              , 1, ismpl), g_c(1, 1, 1, ismpl), d(1, 1, 1, ismpl), &
&              g_d(1, 1, 1, ismpl), e(1, 1, 1, ismpl), g_e(1, 1, 1, &
&              ismpl), f(1, 1, 1, ismpl), g_f(1, 1, 1, ismpl), g(1, 1&
&              , 1, ismpl), g_g(1, 1, 1, ismpl))
!$OMP   do schedule(static) collapse(3)
    DO k=1,k0
      DO j=1,j0
        DO i=1,i0
          src = 0.0d0
!             buoyancy
          IF (k .LT. k0) THEN
            g_result1 = g_BUOY(i, j, k, ismpl, result1)
            g_src = g_result1/delz(k)
            src = src + result1/delz(k)
          ELSE
            g_src = 0.D0
          END IF
!IF (k.eq.k0) src = src + buoy(i,j,k-1,ismpl)/delz(k)
          IF (k .GT. 1) THEN
            g_result1 = g_BUOY(i, j, k - 1, ismpl, result1)
            g_src = g_src - g_result1/delz(k)
            src = src - result1/delz(k)
          END IF
!IF (k.eq.1) src = src - buoy(i,j,k,ismpl)/delz(k)
          g_sijk = g_PSTOR(i, j, k, ismpl, sijk)
          g_d(i, j, k, ismpl) = g_d(i, j, k, ismpl) - g_sijk/(&
&           deltf*thetaf)
          d(i, j, k, ismpl) = d(i, j, k, ismpl) - sijk/(deltf*thetaf)
          temp0 = presold(i+(j-1)*i0+(k-1)*i0*j0, cgen_time, ismpl)
          g_w(i, j, k, ismpl) = g_w(i, j, k, ismpl) - (1.0d0-thetaf)&
&           *g_x(i, j, k, ismpl) - sijk*g_presold(i+(j-1)*i0+(k-1)*&
&           i0*j0, cgen_time, ismpl)/deltf - temp0*g_sijk/deltf - &
&           g_src
          w(i, j, k, ismpl) = w(i, j, k, ismpl) - (1.0d0-thetaf)*x(i, j&
&           , k, ismpl) - temp0*(sijk/deltf) - src
          g_w(i, j, k, ismpl) = g_w(i, j, k, ismpl)/thetaf
          w(i, j, k, ismpl) = w(i, j, k, ismpl)/thetaf
        END DO
      END DO
    END DO
!$OMP   end do nowait
  ELSE
! - - - - - - - - steady state  - - - - - - - - - - - - - - - - - - - - -
!$OMP   do schedule(static) collapse(3)
    DO k=1,k0
      DO j=1,j0
        DO i=1,i0
          src = 0.0d0
! buoyancy  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          IF (k .LT. k0) THEN
            g_result1 = g_BUOY(i, j, k, ismpl, result1)
            g_src = g_result1/delz(k)
            src = src + result1/delz(k)
          ELSE
            g_src = 0.D0
          END IF
!IF (k.eq.k0) src = src + buoy(i,j,k-1,ismpl)/delz(k)
          IF (k .GT. 1) THEN
            g_result1 = g_BUOY(i, j, k - 1, ismpl, result1)
            g_src = g_src - g_result1/delz(k)
            src = src - result1/delz(k)
          END IF
!IF (k.eq.1) src = src - buoy(i,j,k,ismpl)/delz(k)
          g_w(i, j, k, ismpl) = g_w(i, j, k, ismpl) - g_src
          w(i, j, k, ismpl) = w(i, j, k, ismpl) - src
        END DO
      END DO
    END DO
!$OMP   end do nowait
  END IF
  RETURN
END SUBROUTINE g_SET_PCOEFRS

