!        Generated by TAPENADE     (INRIA, Ecuador team)
!  tapenade 3.x
!
!  Differentiation of bhpr in reverse (adjoint) mode (with options noISIZE i8):
!   gradient     of useful results: *temp *dbc_data *bcperiod *propunit
!                *pres bhpr
!   with respect to varying inputs: *temp *dbc_data *bcperiod *propunit
!                *pres
!   Plus diff mem management of: temp:in dbc_data:in bcperiod:in
!                propunit:in pres:in simtime:in
! MIT License
!
! Copyright (c) 2020 SHEMAT-Suite
!
! Permission is hereby granted, free of charge, to any person obtaining a copy
! of this software and associated documentation files (the "Software"), to deal
! in the Software without restriction, including without limitation the rights
! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
! copies of the Software, and to permit persons to whom the Software is
! furnished to do so, subject to the following conditions:
!
! The above copyright notice and this permission notice shall be included in all
! copies or substantial portions of the Software.
!
! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
! SOFTWARE.
!> @brief calculate well pressure according to Shu,2005
!> @param[in] ismpl local sample index
!> @param[in] ii i cell-index
!> @param[in] jj i cell-index
!> @param[in] kk i cell-index
!> @details
!> Reference: J. Shu\n COMPARISON OF VARIOUS TECHINQUES FOR COMPUTING
!> WELL INDEX\n Master Thesis, Stanford 2005\n\n
!>
!> modify coefficents for the head equation according to the boundary
!> conditions, coefficients are stored as vectors in the diagonals a-g
!> (d center), and rhs in w.\n
SUBROUTINE BHPR_AD(ii, jj, kk, ismpl, bhpr_adv)
  use arrays

  USE ARRAYS_AD

  USE MOD_GENRL
  USE MOD_GENRLC
  USE MOD_TEMP
  USE MOD_FLOW
  use mod_time

  USE MOD_TIME_AD

  USE MOD_LINFOS
  IMPLICIT NONE
  double precision :: bhpr_adv
  INTEGER :: ismpl
  INTEGER :: i, j, k
  INTEGER :: ib
!
  INTEGER :: ii, jj, kk, bcu, tpbcu, bctype, i_dir
  DOUBLE PRECISION :: val, malfa, mbeta
  DOUBLE PRECISION :: val_ad, malfa_ad, mbeta_ad
  DOUBLE PRECISION :: d_x, d_y, d_z, k_x, k_y, k_z, wi_x, wi_y, wi_z, &
& wi_pj
  DOUBLE PRECISION :: k_x_ad, k_y_ad, wi_z_ad, wi_pj_ad
! DOUBLE PRECISION l_x,l_y
  DOUBLE PRECISION :: l_z
  DOUBLE PRECISION :: r_b, r_w, skin
  DOUBLE PRECISION :: r_b_ad
! DOUBLE PRECISION xz,zx,yz,zy
  DOUBLE PRECISION :: xy, yx
  DOUBLE PRECISION :: xy_ad, yx_ad
!
  EXTERNAL KX, KY, KZ, VISF
  EXTERNAL KX_AD, KY_AD, KZ_AD, VISF_AD
  DOUBLE PRECISION :: KX, KY, KZ, VISF
  PARAMETER (skin=0.d0, r_w=0.15)
!
  INTRINSIC MAX
  INTRINSIC SQRT
  INTRINSIC LOG
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: result1_ad
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
! dirichlet nodes - - - - - - - - - - - - - - - - - - - - - - - - - - -
! neumann  nodes    - - - - - - - - - - - - - - - - - - - - - - - - - -
!
! default well pressure
  DOUBLE PRECISION :: temp0
  DOUBLE PRECISION :: temporary_ad
  DOUBLE PRECISION :: temp1
  DOUBLE PRECISION :: temp2
  DOUBLE PRECISION :: temp3
  DOUBLE PRECISION :: temp4
  DOUBLE PRECISION :: temporary_ad0
  DOUBLE PRECISION :: temporary_ad1
  DOUBLE PRECISION :: temporary_ad2
  INTEGER :: branch
  DOUBLE PRECISION :: bhpr
  DO ib=first_flow,last_flow
    CALL PUSHINTEGER8(i)
    i = ibc_data(ib, cbc_i)
    CALL PUSHINTEGER8(j)
    j = ibc_data(ib, cbc_j)
    CALL PUSHINTEGER8(k)
    k = ibc_data(ib, cbc_k)
    bctype = ibc_data(ib, cbc_bt)
! neumann bc?, skip otherwise
! data point? skip otherwise
    IF (ii .EQ. i .AND. jj .EQ. j .AND. kk .EQ. k .AND. bctype .EQ. &
&       bt_neuw) THEN
      IF (ibc_data(ib, cbc_bctp) .LT. 0) THEN
        tpbcu = 0
      ELSE
        tpbcu = ibc_data(ib, cbc_bctp)
      END IF
! WELLMODEL
! discrete values
      CALL PUSHREAL8(val)
      val = dbc_data(ib, 1, ismpl)
      IF (tpbcu .GT. 0 .AND. nbctp .GT. 0) THEN
! time-dependent bc:  val=ac*val+bc
! get Alfa and Beta modificators
        CALL PUSHINTEGER8(tpbcu)
        CALL PUSHREAL8(mbeta)
        CALL GET_TPBCALBE(malfa, mbeta, tpbcu, ismpl)
! update time dependend modification of the bc-value
        CALL PUSHREAL8(val)
        val = malfa + mbeta*val
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
!
      IF (tpbcu .GE. 0) THEN
        CALL PUSHREAL8(k_x)
        k_x = KX(i, j, k, ismpl)
        CALL PUSHREAL8(k_y)
        k_y = KY(i, j, k, ismpl)
        d_x = delx(i)
        d_y = dely(j)
        d_z = delz(k)
!             l_x=0.d0
!             yz=k_y/k_z
!             zy=k_z/k_y
!             r_b=0.28d0*sqrt((sqrt(yz)*d_z**2+sqrt(zy)*d_y**2))/ &
!                                       (yz**0.25+zy**0.25)
!             wi_x = 2.0d0*pi*sqrt(k_y*k_z)*l_x/(log(r_b/r_w)+skin)
        wi_x = 0.0d0
!             l_y=0.d0
!             xz=k_x/k_z
!             zx=k_z/k_x
!             r_b=0.28d0*sqrt((sqrt(xz)*d_z**2+sqrt(zx)*d_x**2))/ &
!                                       (xz**0.25+zx**0.25)
!             wi_y = 2.0d0*pi*sqrt(k_x*k_z)*l_y/(log(r_b/r_w)+skin)
        wi_y = 0.0d0
        l_z = d_z
        xy = k_x/k_y
        yx = k_y/k_x
        CALL PUSHREAL8(r_b)
        r_b = 0.28d0*SQRT(SQRT(xy)*d_y**2+SQRT(yx)*d_x**2)/(xy**0.25+yx&
&         **0.25)
        CALL PUSHREAL8(wi_z)
        wi_z = 2.0d0*pi*SQRT(k_x*k_y)*l_z/(LOG(r_b/r_w)+skin)
        CALL PUSHREAL8(wi_pj)
        wi_pj = SQRT(wi_x**2 + wi_y**2 + wi_z**2)
        CALL PUSHREAL8(result1)
        result1 = VISF(i, j, k, ismpl)
        bhpr = pres(i, j, k, ismpl) + val*result1/wi_pj
        dbc_data(ib, 3, ismpl) = bhpr
        CALL PUSHCONTROL2B(2)
      ELSE
        CALL PUSHCONTROL2B(1)
      END IF
    ELSE
      CALL PUSHCONTROL2B(0)
    END IF
  END DO
  DO ib=last_flow,first_flow,-1
    CALL POPCONTROL2B(branch)
    IF (branch .NE. 0) THEN
      IF (branch .EQ. 1) THEN
        val_ad = 0.D0
      ELSE
        bhpr_adv = bhpr_adv + dbc_data_ad(ib, 3, ismpl)
        dbc_data_ad(ib, 3, ismpl) = 0.D0
        pres_ad(i, j, k, ismpl) = pres_ad(i, j, k, ismpl) + bhpr_adv
        temporary_ad2 = bhpr_adv/wi_pj
        val_ad = result1*temporary_ad2
        result1_ad = val*temporary_ad2
        wi_pj_ad = -(val*result1*temporary_ad2/wi_pj)
        CALL POPREAL8(result1)
        CALL VISF_AD(i, j, k, ismpl, result1_ad)
        wi_y = 0.0d0
        wi_x = 0.0d0
        CALL POPREAL8(wi_pj)
        IF (wi_x**2 + wi_y**2 + wi_z**2 .EQ. 0.0) THEN
          wi_z_ad = 0.D0
        ELSE
          wi_z_ad = 2*wi_z*wi_pj_ad/(2.0*SQRT(wi_x**2+wi_y**2+wi_z**2))
        END IF
        d_z = delz(k)
        l_z = d_z
        CALL POPREAL8(wi_z)
        temp4 = skin + LOG(r_b/r_w)
        temp2 = k_x*k_y
        temp1 = SQRT(temp2)
        temporary_ad1 = pi*2.0d0*l_z*wi_z_ad/temp4
        IF (temp2 .EQ. 0.0) THEN
          k_x_ad = 0.D0
        ELSE
          k_x_ad = k_y*temporary_ad1/(2.0*temp1)
        END IF
        IF (temp2 .EQ. 0.0) THEN
          k_y_ad = 0.D0
        ELSE
          k_y_ad = k_x*temporary_ad1/(2.0*temp1)
        END IF
        r_b_ad = -(temp1*temporary_ad1/(r_b*temp4))
        xy = k_x/k_y
        d_x = delx(i)
        d_y = dely(j)
        yx = k_y/k_x
        CALL POPREAL8(r_b)
        temp0 = xy**0.25 + yx**0.25
        temp1 = SQRT(yx)
        temp2 = SQRT(xy)
        temp3 = d_y*d_y*temp2 + d_x*d_x*temp1
        temp4 = SQRT(temp3)
        temporary_ad = 0.28d0*r_b_ad/temp0
        temporary_ad0 = -(temp4*temporary_ad/temp0)
        IF (xy .EQ. 0.0 .OR. temp3 .EQ. 0.0) THEN
          xy_ad = 0.25*xy**(-0.75)*temporary_ad0
        ELSE
          xy_ad = d_y**2*temporary_ad/(2.0**2*temp2*temp4) + 0.25*xy**(-0.75)&
&           *temporary_ad0
        END IF
        IF (yx .EQ. 0.0 .OR. temp3 .EQ. 0.0) THEN
          yx_ad = 0.25*yx**(-0.75)*temporary_ad0
        ELSE
          yx_ad = d_x**2*temporary_ad/(2.0**2*temp1*temp4) + 0.25*yx**(-0.75)&
&           *temporary_ad0
        END IF
        k_y_ad = k_y_ad + yx_ad/k_x - k_x*xy_ad/k_y**2
        k_x_ad = k_x_ad + xy_ad/k_y - k_y*yx_ad/k_x**2
        CALL POPREAL8(k_y)
        CALL KY_AD(i, j, k, ismpl, k_y_ad)
        CALL POPREAL8(k_x)
        CALL KX_AD(i, j, k, ismpl, k_x_ad)
        bhpr_adv = 0.D0
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(val)
        malfa_ad = val_ad
        mbeta_ad = val*val_ad
        val_ad = mbeta*val_ad
        CALL POPREAL8(mbeta)
        CALL POPINTEGER8(tpbcu)
        CALL GET_TPBCALBE_AD(malfa, malfa_ad, mbeta, mbeta_ad, tpbcu, &
&                      ismpl)
      END IF
      CALL POPREAL8(val)
      dbc_data_ad(ib, 1, ismpl) = dbc_data_ad(ib, 1, ismpl) + val_ad
    END IF
    CALL POPINTEGER8(k)
    CALL POPINTEGER8(j)
    CALL POPINTEGER8(i)
  END DO
END SUBROUTINE BHPR_AD

