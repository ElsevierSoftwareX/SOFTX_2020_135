!        Generated by TAPENADE     (INRIA, Ecuador team)
!  tapenade 3.x
!
!  Differentiation of forward_compute in reverse (adjoint) mode (with options noISIZE i8):
!   gradient     of useful results: doutput
!   with respect to varying inputs: *d *e *f *concold *g *temp
!                *w *headold *x *sdata *head *dbc_data *bcperiod
!                *tempold *propunit *presold *conc *pres *a *b
!                *c doutput dinput
!   RW status of diff variables: *d:out *e:out *f:out *concold:out
!                *g:out *temp:out *w:out *headold:out *x:out *sdata:out
!                *head:out *dbc_data:out *bcperiod:out *tempold:out
!                *propunit:out *presold:out *conc:out *pres:out
!                *a:out *b:out *c:out doutput:in-out dinput:out
!                (global)thetaf:(loc) (global)thetat:(loc)
!   Plus diff mem management of: d:in e:in f:in concold:in g:in
!                temp:in w:in headold:in x:in sdata:in head:in
!                dbc_data:in bcperiod:in tempold:in propunit:in
!                presold:in conc:in pres:in simtime:in a:in b:in
!                c:in
! MIT License
!
! Copyright (c) 2020 SHEMAT-Suite
!
! Permission is hereby granted, free of charge, to any person obtaining a copy
! of this software and associated documentation files (the "Software"), to deal
! in the Software without restriction, including without limitation the rights
! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
! copies of the Software, and to permit persons to whom the Software is
! furnished to do so, subject to the following conditions:
!
! The above copyright notice and this permission notice shall be included in all
! copies or substantial portions of the Software.
!
! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
! SOFTWARE.
!>    @brief dependency wrapper (parameter -> simulation) useful for INVERSE and SIMUL
!>    @param[in] dinput parameter vector for initial setup (dependency vector)
!>    @param[out] doutput simulated/computed data/result values
!>    @param[in] simtime_run start time of the simulation
!>    @param[in] simtime_end finish time of the simulation
!>    @param[in] iter_out inverse iteration, SM realisation
!>    @param[in] iseed 0: FW simulation, 1 .. <mpara>: AD seeding index
!>    @param[in] ismpl local sample index
SUBROUTINE FORWARD_COMPUTE_AD(dinput, dinput_ad, doutput, doutput_ad, &
& simtime_run, simtime_end, iter_out, iseed, ismpl)
  use arrays

  USE ARRAYS_AD

  USE MOD_DATA
  USE MOD_GENRL
  IMPLICIT NONE
  INTEGER :: ismpl
  INTEGER :: i
!       input vector
  DOUBLE PRECISION :: dinput(mpara)
  DOUBLE PRECISION :: dinput_ad(mpara)
!       output vector
  DOUBLE PRECISION :: doutput(ndata)
  DOUBLE PRECISION :: doutput_ad(ndata)
!       benchmark time meassurment stuff
!       parameter declaration
  INTEGER :: iter_out, iseed
  DOUBLE PRECISION :: simtime_run, simtime_end
  INTEGER :: branch
!
!
!       dependency setup of the parameters
  DO i=1,mpara
    IF (ALLOCATED(propunit)) THEN
      CALL PUSHREAL8ARRAY(propunit, SIZE(propunit, 1)*SIZE(propunit, 2)*&
&                   SIZE(propunit, 3))
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    CALL SET_OPTIP(i, dinput(i), ismpl)
  END DO
!       run forward iteration
  IF (ALLOCATED(c)) THEN
    CALL PUSHREAL8ARRAY(c, SIZE(c, 1)*SIZE(c, 2)*SIZE(c, 3)*SIZE(c, 4))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ALLOCATED(b)) THEN
    CALL PUSHREAL8ARRAY(b, SIZE(b, 1)*SIZE(b, 2)*SIZE(b, 3)*SIZE(b, 4))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ALLOCATED(a)) THEN
    CALL PUSHREAL8ARRAY(a, SIZE(a, 1)*SIZE(a, 2)*SIZE(a, 3)*SIZE(a, 4))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ALLOCATED(simtime)) THEN
    CALL PUSHREAL8ARRAY(simtime, SIZE(simtime, 1))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ALLOCATED(pres)) THEN
    CALL PUSHREAL8ARRAY(pres, SIZE(pres, 1)*SIZE(pres, 2)*SIZE(pres, 3)*&
&                 SIZE(pres, 4))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ALLOCATED(conc)) THEN
    CALL PUSHREAL8ARRAY(conc, SIZE(conc, 1)*SIZE(conc, 2)*SIZE(conc, 3)*&
&                 SIZE(conc, 4)*SIZE(conc, 5))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ALLOCATED(presold)) THEN
    CALL PUSHREAL8ARRAY(presold, SIZE(presold, 1)*SIZE(presold, 2)*SIZE(&
&                 presold, 3))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ALLOCATED(delt_count)) THEN
    CALL PUSHINTEGER8ARRAY(delt_count, SIZE(delt_count, 1))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ALLOCATED(flag_delt)) THEN
    CALL PUSHINTEGER8ARRAY(flag_delt, SIZE(flag_delt, 1))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ALLOCATED(flag_1st_timestep)) THEN
    CALL PUSHINTEGER8ARRAY(flag_1st_timestep, SIZE(flag_1st_timestep, 1)&
&                   )
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ALLOCATED(tempold)) THEN
    CALL PUSHREAL8ARRAY(tempold, SIZE(tempold, 1)*SIZE(tempold, 2)*SIZE(&
&                 tempold, 3))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ALLOCATED(omp_iglobal)) THEN
    CALL PUSHINTEGER8ARRAY(omp_iglobal, SIZE(omp_iglobal, 1)*SIZE(&
&                    omp_iglobal, 2)*SIZE(omp_iglobal, 3))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ALLOCATED(dbc_data)) THEN
    CALL PUSHREAL8ARRAY(dbc_data, SIZE(dbc_data, 1)*SIZE(dbc_data, 2)*&
&                 SIZE(dbc_data, 3))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ALLOCATED(delt_old)) THEN
    CALL PUSHREAL8ARRAY(delt_old, SIZE(delt_old, 1))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ALLOCATED(omp_dglobal)) THEN
    CALL PUSHREAL8ARRAY(omp_dglobal, SIZE(omp_dglobal, 1)*SIZE(&
&                 omp_dglobal, 2)*SIZE(omp_dglobal, 3))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ALLOCATED(head)) THEN
    CALL PUSHREAL8ARRAY(head, SIZE(head, 1)*SIZE(head, 2)*SIZE(head, 3)*&
&                 SIZE(head, 4))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ALLOCATED(conv_ipos)) THEN
    CALL PUSHINTEGER8ARRAY(conv_ipos, SIZE(conv_ipos, 1)*SIZE(conv_ipos&
&                    , 2))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ALLOCATED(x)) THEN
    CALL PUSHREAL8ARRAY(x, SIZE(x, 1)*SIZE(x, 2)*SIZE(x, 3)*SIZE(x, 4))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ALLOCATED(headold)) THEN
    CALL PUSHREAL8ARRAY(headold, SIZE(headold, 1)*SIZE(headold, 2)*SIZE(&
&                 headold, 3))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ALLOCATED(w)) THEN
    CALL PUSHREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ALLOCATED(lcon)) THEN
    CALL PUSHBOOLEANARRAY(lcon, SIZE(lcon, 1)*SIZE(lcon, 2))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ALLOCATED(conc_conv)) THEN
    CALL PUSHREAL8ARRAY(conc_conv, SIZE(conc_conv, 1)*SIZE(conc_conv, 2)&
&                )
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ALLOCATED(tr_switch)) THEN
    CALL PUSHBOOLEANARRAY(tr_switch, SIZE(tr_switch, 1))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ALLOCATED(conv_chlen)) THEN
    CALL PUSHINTEGER8ARRAY(conv_chlen, SIZE(conv_chlen, 1)*SIZE(&
&                    conv_chlen, 2))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ALLOCATED(temp)) THEN
    CALL PUSHREAL8ARRAY(temp, SIZE(temp, 1)*SIZE(temp, 2)*SIZE(temp, 3)*&
&                 SIZE(temp, 4))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ALLOCATED(g)) THEN
    CALL PUSHREAL8ARRAY(g, SIZE(g, 1)*SIZE(g, 2)*SIZE(g, 3)*SIZE(g, 4))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ALLOCATED(concold)) THEN
    CALL PUSHREAL8ARRAY(concold, SIZE(concold, 1)*SIZE(concold, 2)*SIZE(&
&                 concold, 3)*SIZE(concold, 4))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ALLOCATED(f)) THEN
    CALL PUSHREAL8ARRAY(f, SIZE(f, 1)*SIZE(f, 2)*SIZE(f, 3)*SIZE(f, 4))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ALLOCATED(conv_history)) THEN
    CALL PUSHREAL8ARRAY(conv_history, SIZE(conv_history, 1)*SIZE(&
&                 conv_history, 2)*SIZE(conv_history, 3))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ALLOCATED(e)) THEN
    CALL PUSHREAL8ARRAY(e, SIZE(e, 1)*SIZE(e, 2)*SIZE(e, 3)*SIZE(e, 4))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ALLOCATED(d)) THEN
    CALL PUSHREAL8ARRAY(d, SIZE(d, 1)*SIZE(d, 2)*SIZE(d, 3)*SIZE(d, 4))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  CALL FORWARD_ITER(simtime_run, simtime_end, iter_out, iseed, &
&                    ismpl)
!       copy result values
!
!
!
  IF (ALLOCATED(sdata_ad)) sdata_ad = 0.D0
  CALL DCOPY_AD(ndata, sdata(1, ismpl), sdata_ad(1, ismpl), 1, doutput, &
&         doutput_ad, 1)
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPREAL8ARRAY(d, SIZE(d, 1)*SIZE(d, 2)*SIZE(d&
&                                 , 3)*SIZE(d, 4))
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPREAL8ARRAY(e, SIZE(e, 1)*SIZE(e, 2)*SIZE(e&
&                                 , 3)*SIZE(e, 4))
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPREAL8ARRAY(conv_history, SIZE(conv_history&
&                                 , 1)*SIZE(conv_history, 2)*SIZE(&
&                                 conv_history, 3))
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPREAL8ARRAY(f, SIZE(f, 1)*SIZE(f, 2)*SIZE(f&
&                                 , 3)*SIZE(f, 4))
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPREAL8ARRAY(concold, SIZE(concold, 1)*SIZE(&
&                                 concold, 2)*SIZE(concold, 3)*SIZE(&
&                                 concold, 4))
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPREAL8ARRAY(g, SIZE(g, 1)*SIZE(g, 2)*SIZE(g&
&                                 , 3)*SIZE(g, 4))
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPREAL8ARRAY(temp, SIZE(temp, 1)*SIZE(temp, 2&
&                                 )*SIZE(temp, 3)*SIZE(temp, 4))
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPINTEGER8ARRAY(conv_chlen, SIZE(conv_chlen, &
&                                    1)*SIZE(conv_chlen, 2))
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPBOOLEANARRAY(tr_switch, SIZE(tr_switch, 1))
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPREAL8ARRAY(conc_conv, SIZE(conc_conv, 1)*&
&                                 SIZE(conc_conv, 2))
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPBOOLEANARRAY(lcon, SIZE(lcon, 1)*SIZE(lcon&
&                                   , 2))
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w&
&                                 , 3)*SIZE(w, 4))
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPREAL8ARRAY(headold, SIZE(headold, 1)*SIZE(&
&                                 headold, 2)*SIZE(headold, 3))
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPREAL8ARRAY(x, SIZE(x, 1)*SIZE(x, 2)*SIZE(x&
&                                 , 3)*SIZE(x, 4))
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPINTEGER8ARRAY(conv_ipos, SIZE(conv_ipos, 1)&
&                                    *SIZE(conv_ipos, 2))
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPREAL8ARRAY(head, SIZE(head, 1)*SIZE(head, 2&
&                                 )*SIZE(head, 3)*SIZE(head, 4))
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPREAL8ARRAY(omp_dglobal, SIZE(omp_dglobal, 1&
&                                 )*SIZE(omp_dglobal, 2)*SIZE(&
&                                 omp_dglobal, 3))
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPREAL8ARRAY(delt_old, SIZE(delt_old, 1))
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPREAL8ARRAY(dbc_data, SIZE(dbc_data, 1)*SIZE&
&                                 (dbc_data, 2)*SIZE(dbc_data, 3))
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPINTEGER8ARRAY(omp_iglobal, SIZE(omp_iglobal&
&                                    , 1)*SIZE(omp_iglobal, 2)*SIZE(&
&                                    omp_iglobal, 3))
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPREAL8ARRAY(tempold, SIZE(tempold, 1)*SIZE(&
&                                 tempold, 2)*SIZE(tempold, 3))
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPINTEGER8ARRAY(flag_1st_timestep, SIZE(&
&                                    flag_1st_timestep, 1))
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPINTEGER8ARRAY(flag_delt, SIZE(flag_delt, 1)&
&                                   )
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPINTEGER8ARRAY(delt_count, SIZE(delt_count, &
&                                    1))
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPREAL8ARRAY(presold, SIZE(presold, 1)*SIZE(&
&                                 presold, 2)*SIZE(presold, 3))
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPREAL8ARRAY(conc, SIZE(conc, 1)*SIZE(conc, 2&
&                                 )*SIZE(conc, 3)*SIZE(conc, 4)*SIZE(&
&                                 conc, 5))
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPREAL8ARRAY(pres, SIZE(pres, 1)*SIZE(pres, 2&
&                                 )*SIZE(pres, 3)*SIZE(pres, 4))
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPREAL8ARRAY(simtime, SIZE(simtime, 1))
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPREAL8ARRAY(a, SIZE(a, 1)*SIZE(a, 2)*SIZE(a&
&                                 , 3)*SIZE(a, 4))
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPREAL8ARRAY(b, SIZE(b, 1)*SIZE(b, 2)*SIZE(b&
&                                 , 3)*SIZE(b, 4))
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPREAL8ARRAY(c, SIZE(c, 1)*SIZE(c, 2)*SIZE(c&
&                                 , 3)*SIZE(c, 4))
  CALL FORWARD_ITER_AD(simtime_run, simtime_end, iter_out, iseed, ismpl)
  dinput_ad = 0.D0
  DO i=mpara,1,-1
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 1) CALL POPREAL8ARRAY(propunit, SIZE(propunit, 1)*&
&                                   SIZE(propunit, 2)*SIZE(propunit, 3))
    CALL SET_OPTIP_AD(i, dinput(i), dinput_ad(i), ismpl)
  END DO
END SUBROUTINE FORWARD_COMPUTE_AD

