!        Generated by TAPENADE     (INRIA, Ecuador team)
!  tapenade 3.x
!
!  Differentiation of save_data in reverse (adjoint) mode (with options noISIZE i8):
!   gradient     of useful results: *concold *temp *headold *sdata
!                *head *dbc_data *bcperiod *tempold *propunit *presold
!                *conc *pres
!   with respect to varying inputs: *concold *temp *headold *sdata
!                *head *dbc_data *bcperiod *tempold *propunit *presold
!                *conc *pres
!   Plus diff mem management of: concold:in temp:in headold:in
!                sdata:in head:in dbc_data:in bcperiod:in tempold:in
!                propunit:in presold:in conc:in pres:in simtime:in
! MIT License
!
! Copyright (c) 2020 SHEMAT-Suite
!
! Permission is hereby granted, free of charge, to any person obtaining a copy
! of this software and associated documentation files (the "Software"), to deal
! in the Software without restriction, including without limitation the rights
! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
! copies of the Software, and to permit persons to whom the Software is
! furnished to do so, subject to the following conditions:
!
! The above copyright notice and this permission notice shall be included in all
! copies or substantial portions of the Software.
!
! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
! SOFTWARE.
!> @brief Save simulated variable values for later comparison with input data
!> @param[in] ismpl local sample index
!> @details
!> Set the values of sdata from computed (example: head) and old
!> variable arrays (example: headold). \n
!> sdata will be compared to the read in values in ddata. \n\n
!>
!> Two linear interpolations of the values are implemented:\n
!> 1. A linear interpolation of the position of the data (px,py,pz)
!>    inside the grid
!> 2. according to how the time specified for the data
!>    (ddata(l,cdd_time)) is located between the previous simulation
!>    time (simtime(ismpl)) and the current simulation time
!>    (simtime(ismpl)+deltt). \n\n
!>
!> collect and save the computed values for a comparison with
!> 'ddata(:,cid_pv)'\n
!> -> usage in 'write_data.f' and 'forward/j_*-array(inversion)'\n
SUBROUTINE SAVE_DATA_AD(ismpl)
  use arrays

  USE ARRAYS_AD

  USE MOD_GENRL
  USE MOD_DATA
  use mod_time

  USE MOD_TIME_AD

  USE MOD_LINFOS
  IMPLICIT NONE
  INTEGER :: ismpl
  INTEGER :: i, j, k, l
  EXTERNAL DELTAT, INTERPOLATELIN, BHPR
  EXTERNAL INTERPOLATELIN_AD, BHPR_AD
  DOUBLE PRECISION :: deltt, DELTAT, numdiff, dalfa, dbeta, &
& INTERPOLATELIN, BHPR
  DOUBLE PRECISION :: px, py, pz, vals, vals_old
  DOUBLE PRECISION :: vals_ad, vals_old_ad
  INTEGER :: i_type, i_si
  DOUBLE PRECISION :: res
  DOUBLE PRECISION :: res_ad
  INTEGER :: branch
! get current time step, set 1.0d0 for steady state
  deltt = DELTAT(simtime(ismpl), ismpl)
  IF (.NOT.transient) deltt = 1.d0
!       allowed numerical difference
  numdiff = 1.0d2*const_dble(1)*simtime(ismpl)
!
  DO l=1,ndata
!         correct time interval, or steady-state
    IF ((ddata(l, cdd_time) .GT. simtime(ismpl) + numdiff .AND. ddata(l&
&       , cdd_time) .LE. simtime(ismpl) + deltt + numdiff) .OR. (.NOT.&
&       transient)) THEN
      i = idata(l, cid_i)
      j = idata(l, cid_j)
      k = idata(l, cid_k)
      px = ddata(l, cdd_i)
      py = ddata(l, cdd_j)
      pz = ddata(l, cdd_k)
      i_type = idata(l, cid_pv)
      i_si = idata(l, cid_si)
!           interpolation: m=(a*n+b*o)/(a+b)
      CALL PUSHREAL8(dalfa)
      dalfa = ddata(l, cdd_time) - simtime(ismpl)
      CALL PUSHREAL8(dbeta)
      dbeta = deltt - dalfa
      IF (.NOT.transient) THEN
        dalfa = 1.d0
        dbeta = 0.d0
      END IF
!           choose physical value to save
      IF (i_type .EQ. pv_head) THEN
        CALL PUSHCONTROL3B(0)
      ELSE IF (i_type .EQ. pv_pres) THEN
        CALL PUSHCONTROL3B(1)
      ELSE IF (i_type .EQ. pv_temp) THEN
        CALL PUSHCONTROL3B(2)
      ELSE IF (i_type .EQ. pv_conc) THEN
        CALL PUSHCONTROL3B(3)
      ELSE IF (i_type .EQ. pv_bhpr) THEN
        IF (ALLOCATED(dbc_data)) THEN
          CALL PUSHREAL8ARRAY(dbc_data, SIZE(dbc_data, 1)*SIZE(dbc_data&
&                       , 2)*SIZE(dbc_data, 3))
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        res = BHPR(i, j, k, ismpl)
        CALL PUSHCONTROL3B(4)
      ELSE
        CALL PUSHCONTROL3B(5)
      END IF
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
  END DO
  DO l=ndata,1,-1
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      vals_ad = dalfa*sdata_ad(l, ismpl)/deltt
      vals_old_ad = dbeta*sdata_ad(l, ismpl)/deltt
      sdata_ad(l, ismpl) = 0.D0
      CALL POPCONTROL3B(branch)
      IF (branch .LT. 3) THEN
        IF (branch .EQ. 0) THEN
          i = idata(l, cid_i)
          j = idata(l, cid_j)
          k = idata(l, cid_k)
          px = ddata(l, cdd_i)
          py = ddata(l, cdd_j)
          pz = ddata(l, cdd_k)
          CALL INTERPOLATELIN_AD(i0, j0, k0, i, j, k, headold(1, &
&                          cgen_time, ismpl), headold_ad(1, cgen_time, &
&                          ismpl), px, py, pz, delx, dely, delz, delxa, &
&                          delya, delza, vals_old_ad)
          CALL INTERPOLATELIN_AD(i0, j0, k0, i, j, k, head(1, 1, 1, &
&                          ismpl), head_ad(1, 1, 1, ismpl), px, py, pz, &
&                          delx, dely, delz, delxa, delya, delza, &
&                          vals_ad)
        ELSE IF (branch .EQ. 1) THEN
          i = idata(l, cid_i)
          j = idata(l, cid_j)
          k = idata(l, cid_k)
          px = ddata(l, cdd_i)
          py = ddata(l, cdd_j)
          pz = ddata(l, cdd_k)
          CALL INTERPOLATELIN_AD(i0, j0, k0, i, j, k, presold(1, &
&                          cgen_time, ismpl), presold_ad(1, cgen_time, &
&                          ismpl), px, py, pz, delx, dely, delz, delxa, &
&                          delya, delza, vals_old_ad)
          CALL INTERPOLATELIN_AD(i0, j0, k0, i, j, k, pres(1, 1, 1, &
&                          ismpl), pres_ad(1, 1, 1, ismpl), px, py, pz, &
&                          delx, dely, delz, delxa, delya, delza, &
&                          vals_ad)
        ELSE
          i = idata(l, cid_i)
          j = idata(l, cid_j)
          k = idata(l, cid_k)
          px = ddata(l, cdd_i)
          py = ddata(l, cdd_j)
          pz = ddata(l, cdd_k)
          CALL INTERPOLATELIN_AD(i0, j0, k0, i, j, k, tempold(1, &
&                          cgen_time, ismpl), tempold_ad(1, cgen_time, &
&                          ismpl), px, py, pz, delx, dely, delz, delxa, &
&                          delya, delza, vals_old_ad)
          CALL INTERPOLATELIN_AD(i0, j0, k0, i, j, k, temp(1, 1, 1, &
&                          ismpl), temp_ad(1, 1, 1, ismpl), px, py, pz&
&                          , delx, dely, delz, delxa, delya, delza, &
&                          vals_ad)
        END IF
      ELSE IF (branch .EQ. 3) THEN
        i = idata(l, cid_i)
        j = idata(l, cid_j)
        k = idata(l, cid_k)
        i_si = idata(l, cid_si)
        px = ddata(l, cdd_i)
        py = ddata(l, cdd_j)
        pz = ddata(l, cdd_k)
        CALL INTERPOLATELIN_AD(i0, j0, k0, i, j, k, concold(1, i_si, &
&                        cgen_time, ismpl), concold_ad(1, i_si, &
&                        cgen_time, ismpl), px, py, pz, delx, dely, delz&
&                        , delxa, delya, delza, vals_old_ad)
        CALL INTERPOLATELIN_AD(i0, j0, k0, i, j, k, conc(1, 1, 1, i_si, &
&                        ismpl), conc_ad(1, 1, 1, i_si, ismpl), px, py, &
&                        pz, delx, dely, delz, delxa, delya, delza, &
&                        vals_ad)
      ELSE IF (branch .EQ. 4) THEN
        vals_ad = vals_ad + vals_old_ad
        i = idata(l, cid_i)
        j = idata(l, cid_j)
        k = idata(l, cid_k)
        res_ad = vals_ad
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 1) CALL POPREAL8ARRAY(dbc_data, SIZE(dbc_data, 1&
&                                       )*SIZE(dbc_data, 2)*SIZE(&
&                                       dbc_data, 3))
        CALL BHPR_AD(i, j, k, ismpl, res_ad)
      END IF
      CALL POPREAL8(dbeta)
      CALL POPREAL8(dalfa)
    END IF
  END DO
END SUBROUTINE SAVE_DATA_AD

