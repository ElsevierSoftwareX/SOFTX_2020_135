!        Generated by TAPENADE     (INRIA, Ecuador team)
!  tapenade 3.x
!
!  Differentiation of set_pcoefrs in reverse (adjoint) mode (with options noISIZE i8):
!   gradient     of useful results: *d *e *f *g *temp *w *x *propunit
!                *presold *pres *a *b *c
!   with respect to varying inputs: *d *e *f *g *temp *w *x *propunit
!                *presold *pres *a *b *c
!   Plus diff mem management of: d:in e:in f:in g:in temp:in w:in
!                x:in propunit:in presold:in pres:in simtime:in
!                a:in b:in c:in
!>    @brief calculate right hand side for the head equation
!>    @param[in] ismpl local sample index
!>    @details
!> calculate right hand side for the head equation\n
!> coefficients are stored as vectors in the diagonals a-g (d center) and rhs in w.\n
SUBROUTINE SET_PCOEFRS_AD(ismpl)
  use arrays

  USE ARRAYS_AD

  USE MOD_GENRL
  USE MOD_GENRLC
  USE MOD_FLOW
  use mod_time

  USE MOD_TIME_AD

  USE MOD_LINFOS
  IMPLICIT NONE
  INTEGER :: ismpl
  INTEGER :: i, j, k
  DOUBLE PRECISION :: src, deltf, sijk
  DOUBLE PRECISION :: src_ad, sijk_ad
  EXTERNAL BUOY, COMPF, COMPM, RHOF, POR, DELTAT, &
&     PSTOR, VISF
  EXTERNAL BUOY_AD, PSTOR_AD
  DOUBLE PRECISION :: BUOY, COMPF, COMPM, RHOF, POR, &
& DELTAT, PSTOR, VISF
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: result1_ad
  INTEGER :: arg1
  DOUBLE PRECISION :: res
  DOUBLE PRECISION :: res_ad
  DOUBLE PRECISION :: res0
  DOUBLE PRECISION :: res_ad0
  DOUBLE PRECISION :: res1
  DOUBLE PRECISION :: res_ad1
  DOUBLE PRECISION :: res2
  DOUBLE PRECISION :: res_ad2
  INTEGER :: branch
  deltf = DELTAT(simtime(ismpl), ismpl)
! rhs: sources
  IF (transient .AND. tr_switch(ismpl)) THEN
    DO k=1,k0
      DO j=1,j0
        DO i=1,i0
!             buoyancy
          IF (k .LT. k0) THEN
            res = BUOY(i, j, k, ismpl)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
!IF (k.eq.k0) src = src + buoy(i,j,k-1,ismpl)/delz(k)
          IF (k .GT. 1) THEN
            arg1 = k - 1
            res0 = BUOY(i, j, arg1, ismpl)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
!IF (k.eq.1) src = src - buoy(i,j,k,ismpl)/delz(k)
          CALL PUSHREAL8(sijk)
          sijk = PSTOR(i, j, k, ismpl)
        END DO
      END DO
    END DO
    DO k=k0,1,-1
      DO j=j0,1,-1
        DO i=i0,1,-1
          w_ad(i, j, k, ismpl) = w_ad(i, j, k, ismpl)/thetaf
          x_ad(i, j, k, ismpl) = x_ad(i, j, k, ismpl) - (1.0d0-thetaf)*&
&           w_ad(i, j, k, ismpl)
          presold_ad(i+(j-1)*i0+(k-1)*i0*j0, cgen_time, ismpl) = &
&           presold_ad(i+(j-1)*i0+(k-1)*i0*j0, cgen_time, ismpl) - sijk*&
&           w_ad(i, j, k, ismpl)/deltf
          sijk_ad = -(presold(i+(j-1)*i0+(k-1)*i0*j0, cgen_time, ismpl)*&
&           w_ad(i, j, k, ismpl)/deltf) - d_ad(i, j, k, ismpl)/(deltf*&
&           thetaf)
          src_ad = -w_ad(i, j, k, ismpl)
          CALL POPREAL8(sijk)
          CALL PSTOR_AD(i, j, k, ismpl, sijk_ad)
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            result1_ad = -(src_ad/delz(k))
            arg1 = k - 1
            res_ad0 = result1_ad
            CALL BUOY_AD(i, j, arg1, ismpl, res_ad0)
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            result1_ad = src_ad/delz(k)
            res_ad = result1_ad
            CALL BUOY_AD(i, j, k, ismpl, res_ad)
          END IF
        END DO
      END DO
    END DO
    CALL OMP_MVP_AD(i0, j0, k0, presold(1, cgen_time, ismpl), presold_ad&
&             (1, cgen_time, ismpl), x(1, 1, 1, ismpl), x_ad(1, 1, 1, &
&             ismpl), a(1, 1, 1, ismpl), a_ad(1, 1, 1, ismpl), b(1, 1, 1&
&             , ismpl), b_ad(1, 1, 1, ismpl), c(1, 1, 1, ismpl), c_ad(1&
&             , 1, 1, ismpl), d(1, 1, 1, ismpl), d_ad(1, 1, 1, ismpl), e&
&             (1, 1, 1, ismpl), e_ad(1, 1, 1, ismpl), f(1, 1, 1, ismpl)&
&             , f_ad(1, 1, 1, ismpl), g(1, 1, 1, ismpl), g_ad(1, 1, 1, &
&             ismpl))
  ELSE
! - - - - - - - - steady state  - - - - - - - - - - - - - - - - - - - - -
    DO k=1,k0
      DO j=1,j0
        DO i=1,i0
! buoyancy  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          IF (k .LT. k0) THEN
            res1 = BUOY(i, j, k, ismpl)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
!IF (k.eq.k0) src = src + buoy(i,j,k-1,ismpl)/delz(k)
          IF (k .GT. 1) THEN
            arg1 = k - 1
            res2 = BUOY(i, j, arg1, ismpl)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
        END DO
      END DO
    END DO
    DO k=k0,1,-1
      DO j=j0,1,-1
        DO i=i0,1,-1
          src_ad = -w_ad(i, j, k, ismpl)
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            result1_ad = -(src_ad/delz(k))
            arg1 = k - 1
            res_ad2 = result1_ad
            CALL BUOY_AD(i, j, arg1, ismpl, res_ad2)
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            result1_ad = src_ad/delz(k)
            res_ad1 = result1_ad
            CALL BUOY_AD(i, j, k, ismpl, res_ad1)
          END IF
        END DO
      END DO
    END DO
  END IF
END SUBROUTINE SET_PCOEFRS_AD

