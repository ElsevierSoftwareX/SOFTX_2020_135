!        Generated by TAPENADE     (INRIA, Ecuador team)
!  tapenade 3.x
!
!  Differentiation of forward_iter in forward (tangent) mode:
!   variations   of useful results: *d *e *f *concold *g *temp
!                *w *headold *x *sdata *head *dbc_data *tempold
!                *presold *conc *pres *a *b *c
!   with respect to varying inputs: *d *e *f *concold *g *temp
!                *w *headold *x *sdata *head *dbc_data *bcperiod
!                *tempold *propunit *presold *conc *pres *a *b
!                *c
!   Plus diff mem management of: d:in e:in f:in concold:in g:in
!                temp:in w:in headold:in x:in sdata:in head:in
!                dbc_data:in bcperiod:in tempold:in propunit:in
!                presold:in conc:in pres:in simtime:in a:in b:in
!                c:in
! MIT License
!
! Copyright (c) 2020 SHEMAT-Suite
!
! Permission is hereby granted, free of charge, to any person obtaining a copy
! of this software and associated documentation files (the "Software"), to deal
! in the Software without restriction, including without limitation the rights
! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
! copies of the Software, and to permit persons to whom the Software is
! furnished to do so, subject to the following conditions:
!
! The above copyright notice and this permission notice shall be included in all
! copies or substantial portions of the Software.
!
! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
! SOFTWARE.
!> @brief time discretisation loop
!> @param[in] iter_out inverse iteration, SM realisation
!> @param[in] simtime_run start time of the simulation
!> @param[in] simtime_end finish time of the simulation
!> @param[in] iseed 0: FW simulation, 1 .. <mpara>: AD seeding index
!> @param[in] ismpl local sample index
!> @details
!> In-a-Nutshell description of this subroutine: \n
!> - Preprocessing before time step loop, initial variable values,
!>   monitoring output, extra steady-state initialisation, status_log\n
!> - Time loop: \n
!>   - before computations: time stepping, saving old variable arrays,
!>     output \n
!>   - computation: calling `forward_wrapper.f90`
!>   - after computations: save simulated data, update simtime,
!>     output, check divergence for variable step size \n
!> - Postprocessing: standard output
SUBROUTINE g_FORWARD_ITER(simtime_run, simtime_end, iter_out, iseed, &
& ismpl)
  USE ARRAYS

  USE g_ARRAYS

  USE MOD_GENRL
  USE MOD_GENRLC
  USE MOD_TIME

  USE g_MOD_TIME

  USE MOD_LINFOS
  IMPLICIT NONE
! wrapper for output
!          call write_outt(deltt,ismpl)
! monitoring output
! initial monitoring output
! local sample index
  INTEGER :: ismpl
! iter_out: inverse iteration, SM realisation
  INTEGER :: iter_out, iseed
! Time step index
  INTEGER :: itimestep
! Size of a time period
  DOUBLE PRECISION :: deltt
! Start time of the simulation
  DOUBLE PRECISION, INTENT(IN) :: simtime_run
! Finish time of the simulation
  DOUBLE PRECISION, INTENT(IN) :: simtime_end
  DOUBLE PRECISION, EXTERNAL :: DELTAT
  INTEGER, EXTERNAL :: LBLANK
! Preprocessing
! -------------
! initial values for some variables/arrays
  flag_1st_timestep(ismpl) = 0
  itimestep = itimestep_0
  simtime(ismpl) = simtime_run
  deltt = DELTAT(simtime(ismpl), ismpl)
  tr_switch(ismpl) = .true.
  iter_nlold = maxiter_nl/2
!          call write_monitor(1,ismpl)
!          call write_monitor_user(1,ismpl)
! runmode 2: extra steady state initialisation
  IF (transient .AND. runmode .EQ. 2) THEN
    tr_switch(ismpl) = .false.
    IF (iseed .EQ. 0 .AND. linfos(2) .GE. 0) WRITE(*, '(1A)') &
&                            '  [I] : extra steady state initialisation'
    CALL g_FORWARD_WRAPPER(itimestep, iseed, ismpl)
    IF (iseed .EQ. 0 .AND. linfos(2) .GE. 0) WRITE(*, '(1A)') &
&                                     '  [I] : normal transient process'
    tr_switch(ismpl) = .true.
  END IF
! Write to status_log
  IF (transient .AND. iseed .EQ. 0 .AND. (.NOT.write_iter_disable)) THEN
    OPEN(76, file=status_log, status='unknown', position='append') 
    WRITE(76, fmt='(I8,1e14.6,1e14.6)') itimestep, deltt, simtime(ismpl)&
&   /tunit
    CLOSE(76) 
  END IF
! Time step loop for forward modeling
! -----------------------------------
 1000 IF (transient) THEN
! Advance time step
    itimestep = itimestep + 1
! Initialize flag for variable time step size
    flag_delt(ismpl) = 0
! Time stepping info to standard out
    IF (linfos(1) .GE. 1) THEN
      WRITE(*, *) ' '
      WRITE(*, '(1A,1I6)') '  >>>> new time step: ', itimestep
      WRITE(*, '(1A,1e16.8,1A,1e16.8)') '  >>>>     cum. time= ', (&
&     simtime(ismpl)+deltt)/tunit, '/', max_simtime/tunit
      WRITE(*, '(1A,1e16.8)') '  >>>>     time step= ', deltt/tunit
    END IF
! Save old time level
    CALL g_OLD_SAVE(cgen_time, ismpl)
  END IF
! ######### Forward Iteration ######
  CALL g_FORWARD_WRAPPER(itimestep, iseed, ismpl)
! ##################################
! save and collect the computed values for:
! - comparison with 'ddata(*,cid_pv)' (observed data)
! - data-output (write_data.f)
  CALL g_SAVE_DATA(ismpl)
  IF (transient) THEN
! Update simulation time
    simtime(ismpl) = simtime(ismpl) + deltt
!            call write_monitor(2,ismpl)
!            call write_monitor_user(2,ismpl)
! Write to status_log
    IF (.NOT.write_iter_disable .AND. iseed .EQ. 0) THEN
! Status log info to standard out
      IF (linfos(1) .GE. 1) WRITE(*, '(3A)') '  [W] : "', status_log(1:&
&                           LBLANK(status_log)), '"'
      OPEN(76, file=status_log, status='unknown', position='append') 
      WRITE(76, fmt='(I8,1e14.6,1e14.6)') itimestep, deltt, simtime(&
&     ismpl)/tunit
      CLOSE(76) 
    END IF
! Check for variable time stepping divergence flag
    IF (flag_delt(ismpl) .EQ. -2) THEN
! Restore old values of variable arrays if time step was
! halfed (restoring simtime is handled in "deltat")
      CALL g_OLD_RESTORE(cgen_time, ismpl)
    END IF
! Set variable time stepping divergence flag to zero to
! avoid double calling of deltat.
    flag_delt(ismpl) = 0
    deltt = DELTAT(simtime(ismpl), ismpl)
  END IF
! Important: This if statement (with the goto) needs to be
! outside of the other "transient" scopes, to generate
! reverse-mode code!
  IF (transient .AND. simtime(ismpl) .LT. simtime_end) GOTO 1000
! --------------- 1000: return to next time step ----------------------
! Postprocessing
! --------------
! Write to status_log and status_log_inv
  IF (transient .AND. runmode .GE. 2 .AND. (.NOT.write_iter_disable) &
&     .AND. iseed .EQ. 0) THEN
    WRITE(*, '(3A)') '  [W] : "', status_log(1:LBLANK(status_log)), '"'
    OPEN(76, file=status_log, status='unknown', position='append') 
    WRITE(76, '(1A)') key_char//' transient end'
    CLOSE(76) 
    OPEN(76, file=status_log_inv, status='unknown', position='append') 
    WRITE(76, '(1A,I8,1e14.6,1e14.6)') key_char//' transient: ', &
&   itimestep, deltt, simtime(ismpl)/tunit
    CLOSE(76) 
  END IF
! Standard output: steady state
  IF (iter_out .GT. 0 .AND. linfos(1) .GE. 1 .AND. (.NOT.transient) &
&     .AND. iseed .EQ. 0) WRITE(*, '(29X,1A)') &
&                         ' ===> leaving nonlinear iteration'
! Standard output: transient
  IF (linfos(1) .GE. 0 .AND. transient .AND. iseed .EQ. 0) WRITE(*, &
&                                                    '(1A,I8,1A,1e14.6)'&
&                                                         ) &
&                                           '  [I] : final time step = '&
&                                                          , itimestep, &
&                                                    ', simulation time'&
&                                                          , simtime(&
&                                                          ismpl)/tunit
  RETURN
END SUBROUTINE g_FORWARD_ITER

