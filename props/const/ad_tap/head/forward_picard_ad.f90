!        Generated by TAPENADE     (INRIA, Ecuador team)
!  tapenade 3.x
!
!  Differentiation of forward_picard in reverse (adjoint) mode (with options noISIZE i8):
!   gradient     of useful results: *d *e *f *concold *g *temp
!                *w *headold *x *head *dbc_data *bcperiod *tempold
!                *propunit *presold *conc *pres *a *b *c
!   with respect to varying inputs: *d *e *f *concold *g *temp
!                *w *headold *x *head *dbc_data *bcperiod *tempold
!                *propunit *presold *conc *pres *a *b *c
!   Plus diff mem management of: d:in e:in f:in concold:in g:in
!                temp:in w:in headold:in x:in head:in dbc_data:in
!                bcperiod:in tempold:in propunit:in presold:in
!                conc:in pres:in simtime:in a:in b:in c:in
! MIT License
!
! Copyright (c) 2020 SHEMAT-Suite
!
! Permission is hereby granted, free of charge, to any person obtaining a copy
! of this software and associated documentation files (the "Software"), to deal
! in the Software without restriction, including without limitation the rights
! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
! copies of the Software, and to permit persons to whom the Software is
! furnished to do so, subject to the following conditions:
!
! The above copyright notice and this permission notice shall be included in all
! copies or substantial portions of the Software.
!
! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
! SOFTWARE.
!>    @brief nonlinear picard iteration for flow, heat and transport equation
!>    @param[in] iter_time forward iteration counter
!>    @param[in] ismpl local sample index
!>    @details
!> nonlinear iteration loop (convergency) for steady state and\n
!> transient case (one time step)\n
SUBROUTINE FORWARD_PICARD_AD(iter_time, ismpl)
  use arrays

  USE ARRAYS_AD

  USE MOD_GENRL
  USE MOD_GENRLC
  USE MOD_FLOW
  USE MOD_TEMP
  USE MOD_CONC
  use mod_time

  USE MOD_TIME_AD

  USE MOD_DATA
  USE MOD_LINFOS
  IMPLICIT NONE
  INTEGER :: ismpl
  INTEGER :: i
  INTEGER :: iter_nl
! Maximal difference and RMS-difference between old and new
! variable array
  DOUBLE PRECISION :: difmaxf, difrmsf
  DOUBLE PRECISION :: difmaxf_ad
  DOUBLE PRECISION :: difmaxt, difrmst
  DOUBLE PRECISION :: difmaxt_ad
  DOUBLE PRECISION :: difmaxc, difrmsc
  DOUBLE PRECISION :: difmaxc_ad
  DOUBLE PRECISION :: difmaxs, difrmss
  EXTERNAL CONVERGED, LBLANK
!
  INTEGER :: ijk, mode, iter_time, LBLANK, species
  DOUBLE PRECISION :: neu_max, pec_max, cou_max
  DOUBLE PRECISION :: difmaxfold, difmaxtold, difmaxcold
  DOUBLE PRECISION :: difmaxfold_ad, difmaxtold_ad, difmaxcold_ad
  DOUBLE PRECISION :: relaxold, relaxf, relaxt, relaxc, relaxs
  DOUBLE PRECISION :: relaxold_ad, relaxf_ad, relaxt_ad, relaxc_ad
! Local non linear tolerance variables for convergence check
  DOUBLE PRECISION :: loc_nltolf, loc_nltolt, loc_nltolc, loc_nltols
!
  LOGICAL :: CONVERGED, lcon_sum
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: arg1_ad
  INTEGER :: arg10
  INTEGER :: branch
  INTEGER :: res
  INTEGER :: ad_count
  INTEGER :: i1
! Initialisation
! --------------
! standard output
  IF (linfos(3) .GE. 2) WRITE(*, *) ' ... forward(picard)'
! initial values for variables
  ijk = i0*j0*k0
  mode = 0
  iter_nl = 0
! initialize nonlinear solver parameters: flow
  loc_nltolf = nltolf
  difmaxf = 1.0d9*loc_nltolf
  IF (linfos(3) .GE. 2) WRITE(*, *) 'difmaxf = ', difmaxf
  relaxf = nlrelaxf
! initialize nonlinear solver parameters: temp
  loc_nltolt = nltolt
  difmaxt = 1.0d9*loc_nltolt
  relaxt = nlrelaxt
! initialize nonlinear solver parameters: conc
  loc_nltolc = nltolc
  difmaxc = 1.0d9*loc_nltolc
  relaxc = nlrelaxc
! initialize nonlinear solver parameters: satn
! init history [1] for flow
  lcon(1, ismpl) = CONVERGED(difmaxf, loc_nltolf, -1, conv_hlen, &
&   conv_hmax, conv_history(1, 1, ismpl), conv_chlen(1, ismpl), &
&   conv_ipos(1, ismpl))
! init history [2] for temperature
  lcon(2, ismpl) = CONVERGED(difmaxt, loc_nltolt, -2, conv_hlen, &
&   conv_hmax, conv_history(1, 1, ismpl), conv_chlen(1, ismpl), &
&   conv_ipos(1, ismpl))
! init history for concentration
  DO i=4,ntrans+3
    lcon(i, ismpl) = CONVERGED(difmaxc, loc_nltolc, -i, conv_hlen, &
&     conv_hmax, conv_history(1, 1, ismpl), conv_chlen(1, ismpl), &
&     conv_ipos(1, ismpl))
  END DO
! pre-set to enter the computation at least once
  lcon_sum = .false.
  ad_count = 0
! -------- begin nonlinear iteration
! ----------------------------------
!     LOOP = ITERATION lcon_sum - error !!!
!     LOOP = ITERATION difmaxf,difmaxt,difmaxc - wrong !!!
!$TAF LOOP = ITERATION head,temp,conc,difmaxf,difmaxt,difmaxc
  DO WHILE (.NOT.lcon_sum .AND. iter_nl .LT. maxiter_nl)
! --------
! Preprocessing
! -------------
! loop Counter for outer nonlinear iteration
    CALL PUSHINTEGER8(iter_nl)
    iter_nl = iter_nl + 1
! save old variable arrays for checking difference later
    IF (ALLOCATED(tempold)) THEN
      CALL PUSHREAL8ARRAY(tempold, SIZE(tempold, 1)*SIZE(tempold, 2)*&
&                   SIZE(tempold, 3))
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    IF (ALLOCATED(headold)) THEN
      CALL PUSHREAL8ARRAY(headold, SIZE(headold, 1)*SIZE(headold, 2)*&
&                   SIZE(headold, 3))
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    IF (ALLOCATED(concold)) THEN
      CALL PUSHREAL8ARRAY(concold, SIZE(concold, 1)*SIZE(concold, 2)*&
&                   SIZE(concold, 3)*SIZE(concold, 4))
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    CALL OLD_SAVE(cgen_fw, ismpl)
! static relaxation (only flow and temperature)
    IF (transient .AND. tr_switch(ismpl)) THEN
      IF (ALLOCATED(head)) THEN
        CALL PUSHREAL8ARRAY(head, SIZE(head, 1)*SIZE(head, 2)*SIZE(head&
&                     , 3)*SIZE(head, 4))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      IF (ALLOCATED(temp)) THEN
        CALL PUSHREAL8ARRAY(temp, SIZE(temp, 1)*SIZE(temp, 2)*SIZE(temp&
&                     , 3)*SIZE(temp, 4))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      CALL STATIC_RELAXATION(ijk, ismpl)
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
! user directory functions
    IF (ALLOCATED(simtime)) THEN
      CALL PUSHREAL8ARRAY(simtime, SIZE(simtime, 1))
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    IF (ALLOCATED(delt_count)) THEN
      CALL PUSHINTEGER8ARRAY(delt_count, SIZE(delt_count, 1))
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    IF (ALLOCATED(flag_1st_timestep)) THEN
      CALL PUSHINTEGER8ARRAY(flag_1st_timestep, SIZE(flag_1st_timestep, &
&                      1))
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    IF (ALLOCATED(dbc_data)) THEN
      CALL PUSHREAL8ARRAY(dbc_data, SIZE(dbc_data, 1)*SIZE(dbc_data, 2)*&
&                   SIZE(dbc_data, 3))
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    IF (ALLOCATED(delt_old)) THEN
      CALL PUSHREAL8ARRAY(delt_old, SIZE(delt_old, 1))
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    CALL CALC_USER(ismpl)
! update pressure for current head
    IF (ALLOCATED(pres)) THEN
      CALL PUSHREAL8ARRAY(pres, SIZE(pres, 1)*SIZE(pres, 2)*SIZE(pres, 3&
&                   )*SIZE(pres, 4))
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    IF (ALLOCATED(head)) THEN
      CALL PUSHREAL8ARRAY(head, SIZE(head, 1)*SIZE(head, 2)*SIZE(head, 3&
&                   )*SIZE(head, 4))
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    IF (ALLOCATED(temp)) THEN
      CALL PUSHREAL8ARRAY(temp, SIZE(temp, 1)*SIZE(temp, 2)*SIZE(temp, 3&
&                   )*SIZE(temp, 4))
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    CALL HEAD2PRES(1, ismpl)
! Flow equation
! -------------
! Call solver
    IF (head_active .OR. pres_active) THEN
! head computation
      IF (ALLOCATED(c)) THEN
        CALL PUSHREAL8ARRAY(c, SIZE(c, 1)*SIZE(c, 2)*SIZE(c, 3)*SIZE(c, &
&                     4))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      IF (ALLOCATED(b)) THEN
        CALL PUSHREAL8ARRAY(b, SIZE(b, 1)*SIZE(b, 2)*SIZE(b, 3)*SIZE(b, &
&                     4))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      IF (ALLOCATED(a)) THEN
        CALL PUSHREAL8ARRAY(a, SIZE(a, 1)*SIZE(a, 2)*SIZE(a, 3)*SIZE(a, &
&                     4))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      IF (ALLOCATED(simtime)) THEN
        CALL PUSHREAL8ARRAY(simtime, SIZE(simtime, 1))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      IF (ALLOCATED(delt_count)) THEN
        CALL PUSHINTEGER8ARRAY(delt_count, SIZE(delt_count, 1))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      IF (ALLOCATED(flag_1st_timestep)) THEN
        CALL PUSHINTEGER8ARRAY(flag_1st_timestep, SIZE(flag_1st_timestep&
&                        , 1))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      IF (ALLOCATED(delt_old)) THEN
        CALL PUSHREAL8ARRAY(delt_old, SIZE(delt_old, 1))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      IF (ALLOCATED(x)) THEN
        CALL PUSHREAL8ARRAY(x, SIZE(x, 1)*SIZE(x, 2)*SIZE(x, 3)*SIZE(x, &
&                     4))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      IF (ALLOCATED(w)) THEN
        CALL PUSHREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, &
&                     4))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      IF (ALLOCATED(g)) THEN
        CALL PUSHREAL8ARRAY(g, SIZE(g, 1)*SIZE(g, 2)*SIZE(g, 3)*SIZE(g, &
&                     4))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      IF (ALLOCATED(f)) THEN
        CALL PUSHREAL8ARRAY(f, SIZE(f, 1)*SIZE(f, 2)*SIZE(f, 3)*SIZE(f, &
&                     4))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      IF (ALLOCATED(e)) THEN
        CALL PUSHREAL8ARRAY(e, SIZE(e, 1)*SIZE(e, 2)*SIZE(e, 3)*SIZE(e, &
&                     4))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      IF (ALLOCATED(d)) THEN
        CALL PUSHREAL8ARRAY(d, SIZE(d, 1)*SIZE(d, 2)*SIZE(d, 3)*SIZE(d, &
&                     4))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      CALL CALC_HEAD(ismpl)
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      lcon(1, ismpl) = .true.
    END IF
! evaluate flow
    IF (head_active .OR. pres_active) THEN
! Neumann numbers
      IF (transient .AND. tr_switch(ismpl) .AND. linfos(3) .GE. 1) THEN
        IF (ALLOCATED(simtime)) THEN
          CALL PUSHREAL8ARRAY(simtime, SIZE(simtime, 1))
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        CALL NEUMANN_HEAD(neu_max, ismpl)
!?            CALL Courant(Cou_max,ismpl)
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
! compute difference
      CALL PUSHREAL8(difmaxfold)
      difmaxfold = difmaxf
      IF (linfos(3) .GE. 2) WRITE(*, *) 'Check change with difmaxf = ', &
&                           difmaxf
      IF (ALLOCATED(x)) THEN
        CALL PUSHREAL8ARRAY(x, SIZE(x, 1)*SIZE(x, 2)*SIZE(x, 3)*SIZE(x, &
&                     4))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      CALL PUSHREAL8(difmaxf)
      CALL CHECK_CHANGE(mode, pv_head, loc_nltolf, difrmsf, &
&                        difmaxf, i0, j0, k0, head(1, 1, 1, ismpl), &
&                        headold(1, cgen_fw, ismpl), ismpl)
! check for convergence head/pressure
      lcon(1, ismpl) = CONVERGED(difmaxf, loc_nltolf, 1, conv_hlen, &
&       conv_hmax, conv_history(1, 1, ismpl), conv_chlen(1, ismpl), &
&       conv_ipos(1, ismpl))
! adaptive relaxation
      IF (iter_nl .GE. 2) THEN
! relaxation for better convergence
        IF (nladapt .EQ. 1) THEN
          relaxold = relaxf
! DANGER not working for saturation !
          CALL PUSHREAL8(relaxold)
          CALL PUSHREAL8(relaxf)
          CALL NL_RELAX(iter_nl, difmaxf, difmaxfold, nlmaxf, relaxf, &
&                 relaxold, ismpl)
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
! relaxing head
        IF (ALLOCATED(head)) THEN
          CALL PUSHREAL8ARRAY(head(1, 1, 1, ismpl), SIZE(head, 1))
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        CALL DSCAL(ijk, relaxf, head(1, 1, 1, ismpl), 1)
        arg1 = 1.0d0 - relaxf
        IF (ALLOCATED(head)) THEN
          CALL PUSHREAL8ARRAY(head(1, 1, 1, ismpl), SIZE(head, 1))
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        CALL DAXPY(ijk, arg1, headold(1, cgen_fw, ismpl), 1, head(1, 1, &
&            1, ismpl), 1)
        CALL PUSHCONTROL2B(0)
      ELSE
        CALL PUSHCONTROL2B(1)
      END IF
    ELSE
      CALL PUSHCONTROL2B(2)
    END IF
! Heat equation
! -------------
! Call solver
    IF (temp_active) THEN
      IF (ALLOCATED(c)) THEN
        CALL PUSHREAL8ARRAY(c, SIZE(c, 1)*SIZE(c, 2)*SIZE(c, 3)*SIZE(c, &
&                     4))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      IF (ALLOCATED(b)) THEN
        CALL PUSHREAL8ARRAY(b, SIZE(b, 1)*SIZE(b, 2)*SIZE(b, 3)*SIZE(b, &
&                     4))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      IF (ALLOCATED(a)) THEN
        CALL PUSHREAL8ARRAY(a, SIZE(a, 1)*SIZE(a, 2)*SIZE(a, 3)*SIZE(a, &
&                     4))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      IF (ALLOCATED(simtime)) THEN
        CALL PUSHREAL8ARRAY(simtime, SIZE(simtime, 1))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      IF (ALLOCATED(delt_count)) THEN
        CALL PUSHINTEGER8ARRAY(delt_count, SIZE(delt_count, 1))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      IF (ALLOCATED(flag_1st_timestep)) THEN
        CALL PUSHINTEGER8ARRAY(flag_1st_timestep, SIZE(flag_1st_timestep&
&                        , 1))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      IF (ALLOCATED(delt_old)) THEN
        CALL PUSHREAL8ARRAY(delt_old, SIZE(delt_old, 1))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      IF (ALLOCATED(x)) THEN
        CALL PUSHREAL8ARRAY(x, SIZE(x, 1)*SIZE(x, 2)*SIZE(x, 3)*SIZE(x, &
&                     4))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      IF (ALLOCATED(w)) THEN
        CALL PUSHREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, &
&                     4))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      IF (ALLOCATED(temp)) THEN
        CALL PUSHREAL8ARRAY(temp, SIZE(temp, 1)*SIZE(temp, 2)*SIZE(temp&
&                     , 3)*SIZE(temp, 4))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      IF (ALLOCATED(g)) THEN
        CALL PUSHREAL8ARRAY(g, SIZE(g, 1)*SIZE(g, 2)*SIZE(g, 3)*SIZE(g, &
&                     4))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      IF (ALLOCATED(f)) THEN
        CALL PUSHREAL8ARRAY(f, SIZE(f, 1)*SIZE(f, 2)*SIZE(f, 3)*SIZE(f, &
&                     4))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      IF (ALLOCATED(e)) THEN
        CALL PUSHREAL8ARRAY(e, SIZE(e, 1)*SIZE(e, 2)*SIZE(e, 3)*SIZE(e, &
&                     4))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      IF (ALLOCATED(d)) THEN
        CALL PUSHREAL8ARRAY(d, SIZE(d, 1)*SIZE(d, 2)*SIZE(d, 3)*SIZE(d, &
&                     4))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      CALL CALC_TEMP(ismpl)
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      lcon(2, ismpl) = .true.
    END IF
! Evaluate temperature
    IF (temp_active) THEN
      IF (transient .AND. tr_switch(ismpl) .AND. linfos(3) .GE. 1) THEN
        IF (ALLOCATED(simtime)) THEN
          CALL PUSHREAL8ARRAY(simtime, SIZE(simtime, 1))
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        CALL COURANT(cou_max, ismpl)
        CALL NEUMANN_TEMP(neu_max, ismpl)
        CALL PECLET_TEMP(pec_max, ismpl)
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
! compute difference
      CALL PUSHREAL8(difmaxtold)
      difmaxtold = difmaxt
      IF (ALLOCATED(x)) THEN
        CALL PUSHREAL8ARRAY(x, SIZE(x, 1)*SIZE(x, 2)*SIZE(x, 3)*SIZE(x, &
&                     4))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      CALL PUSHREAL8(difmaxt)
      CALL CHECK_CHANGE(mode, pv_temp, loc_nltolt, difrmst, &
&                        difmaxt, i0, j0, k0, temp(1, 1, 1, ismpl), &
&                        tempold(1, cgen_fw, ismpl), ismpl)
! check for convergence
      lcon(2, ismpl) = CONVERGED(difmaxt, loc_nltolt, 2, conv_hlen, &
&       conv_hmax, conv_history(1, 1, ismpl), conv_chlen(1, ismpl), &
&       conv_ipos(1, ismpl))
! adaptive relaxation
      IF (iter_nl .GE. 2) THEN
! relaxation for better convergence
        IF (nladapt .EQ. 1) THEN
          relaxold = relaxt
          CALL PUSHREAL8(relaxold)
          CALL PUSHREAL8(relaxt)
          CALL NL_RELAX(iter_nl, difmaxt, difmaxtold, nlmaxt, relaxt, &
&                 relaxold, ismpl)
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (ALLOCATED(temp)) THEN
          CALL PUSHREAL8ARRAY(temp(1, 1, 1, ismpl), SIZE(temp, 1))
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        CALL DSCAL(ijk, relaxt, temp(1, 1, 1, ismpl), 1)
        arg1 = 1.0d0 - relaxt
        IF (ALLOCATED(temp)) THEN
          CALL PUSHREAL8ARRAY(temp(1, 1, 1, ismpl), SIZE(temp, 1))
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        CALL DAXPY(ijk, arg1, tempold(1, cgen_fw, ismpl), 1, temp(1, 1, &
&            1, ismpl), 1)
        CALL PUSHCONTROL2B(0)
      ELSE
        CALL PUSHCONTROL2B(1)
      END IF
    ELSE
      CALL PUSHCONTROL2B(2)
    END IF
! Open spot for future implementation of another equation at
! lcon(3,ismpl)
    lcon(3, ismpl) = .true.
! Transport equation
! -------------
    IF (trac_active) THEN
      IF (linfos(3) .GE. 2) THEN
        CALL PUSHCONTROL1B(1)
        WRITE(*, *) ' ... calc_conc (tracer)'
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    DO species=1,ntrac
! Call solver
      IF (trac_active) THEN
        IF (ALLOCATED(c)) THEN
          CALL PUSHREAL8ARRAY(c, SIZE(c, 1)*SIZE(c, 2)*SIZE(c, 3)*SIZE(c&
&                       , 4))
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        IF (ALLOCATED(b)) THEN
          CALL PUSHREAL8ARRAY(b, SIZE(b, 1)*SIZE(b, 2)*SIZE(b, 3)*SIZE(b&
&                       , 4))
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        IF (ALLOCATED(a)) THEN
          CALL PUSHREAL8ARRAY(a, SIZE(a, 1)*SIZE(a, 2)*SIZE(a, 3)*SIZE(a&
&                       , 4))
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        IF (ALLOCATED(simtime)) THEN
          CALL PUSHREAL8ARRAY(simtime, SIZE(simtime, 1))
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        IF (ALLOCATED(conc)) THEN
          CALL PUSHREAL8ARRAY(conc, SIZE(conc, 1)*SIZE(conc, 2)*SIZE(&
&                       conc, 3)*SIZE(conc, 4)*SIZE(conc, 5))
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        IF (ALLOCATED(delt_count)) THEN
          CALL PUSHINTEGER8ARRAY(delt_count, SIZE(delt_count, 1))
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        IF (ALLOCATED(flag_1st_timestep)) THEN
          CALL PUSHINTEGER8ARRAY(flag_1st_timestep, SIZE(&
&                          flag_1st_timestep, 1))
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        IF (ALLOCATED(delt_old)) THEN
          CALL PUSHREAL8ARRAY(delt_old, SIZE(delt_old, 1))
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        IF (ALLOCATED(x)) THEN
          CALL PUSHREAL8ARRAY(x, SIZE(x, 1)*SIZE(x, 2)*SIZE(x, 3)*SIZE(x&
&                       , 4))
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        IF (ALLOCATED(w)) THEN
          CALL PUSHREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w&
&                       , 4))
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        IF (ALLOCATED(g)) THEN
          CALL PUSHREAL8ARRAY(g, SIZE(g, 1)*SIZE(g, 2)*SIZE(g, 3)*SIZE(g&
&                       , 4))
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        IF (ALLOCATED(f)) THEN
          CALL PUSHREAL8ARRAY(f, SIZE(f, 1)*SIZE(f, 2)*SIZE(f, 3)*SIZE(f&
&                       , 4))
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        IF (ALLOCATED(e)) THEN
          CALL PUSHREAL8ARRAY(e, SIZE(e, 1)*SIZE(e, 2)*SIZE(e, 3)*SIZE(e&
&                       , 4))
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        IF (ALLOCATED(d)) THEN
          CALL PUSHREAL8ARRAY(d, SIZE(d, 1)*SIZE(d, 2)*SIZE(d, 3)*SIZE(d&
&                       , 4))
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        CALL CALC_CONC(species, ismpl)
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
        lcon(3+species, ismpl) = .true.
      END IF
! evaluate concentration
      IF (trac_active) THEN
        IF (transient .AND. tr_switch(ismpl) .AND. linfos(3) .GE. 1 &
&           .AND. species .EQ. 1) THEN
          IF (ALLOCATED(simtime)) THEN
            CALL PUSHREAL8ARRAY(simtime, SIZE(simtime, 1))
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
          CALL COURANT(cou_max, ismpl)
          CALL NEUMANN_CONC(neu_max, ismpl)
          CALL PECLET_CONC(pec_max, ismpl)
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
! compute difference
        CALL PUSHREAL8(difmaxcold)
        difmaxcold = difmaxc
! Check change
        IF (ALLOCATED(x)) THEN
          CALL PUSHREAL8ARRAY(x, SIZE(x, 1)*SIZE(x, 2)*SIZE(x, 3)*SIZE(x&
&                       , 4))
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        CALL PUSHREAL8(difmaxc)
        CALL CHECK_CHANGE(mode, pv_conc, loc_nltolc, difrmsc, &
&                          difmaxc, i0, j0, k0, conc(1, 1, 1, species, &
&                          ismpl), concold(1, species, cgen_fw, ismpl), &
&                          ismpl)
! check for convergence
        arg10 = 3 + species
        lcon(3+species, ismpl) = CONVERGED(difmaxc, loc_nltolc, arg10, &
&         conv_hlen, conv_hmax, conv_history(1, 1, ismpl), conv_chlen(1&
&         , ismpl), conv_ipos(1, ismpl))
! adaptive relaxation
        IF (iter_nl .GE. 2) THEN
! relaxation for better convergence
          IF (nladapt .EQ. 1) THEN
            relaxold = relaxc
            CALL PUSHREAL8(relaxold)
            CALL PUSHREAL8(relaxc)
            CALL NL_RELAX(iter_nl, difmaxc, difmaxcold, nlmaxc, relaxc, &
&                   relaxold, ismpl)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (ALLOCATED(conc)) THEN
            CALL PUSHREAL8ARRAY(conc(1, 1, 1, species, ismpl), SIZE(conc&
&                         , 1))
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
          CALL DSCAL(ijk, relaxc, conc(1, 1, 1, species, ismpl), 1)
          arg1 = 1.0d0 - relaxc
          IF (ALLOCATED(conc)) THEN
            CALL PUSHREAL8ARRAY(conc(1, 1, 1, species, ismpl), SIZE(conc&
&                         , 1))
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
          CALL DAXPY(ijk, arg1, concold(1, species, cgen_fw, ismpl), 1, &
&              conc(1, 1, 1, species, ismpl), 1)
          CALL PUSHCONTROL2B(1)
        ELSE
          CALL PUSHCONTROL2B(2)
        END IF
        conc_conv(species, ismpl) = difmaxc
      ELSE
        CALL PUSHCONTROL2B(0)
      END IF
    END DO
! Postprocessing
! -------------
!         check whether pres/temp/(conc) in domain of props validity
    IF (ALLOCATED(pres)) THEN
      CALL PUSHREAL8ARRAY(pres, SIZE(pres, 1)*SIZE(pres, 2)*SIZE(pres, 3&
&                   )*SIZE(pres, 4))
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    IF (ALLOCATED(conc)) THEN
      CALL PUSHREAL8ARRAY(conc, SIZE(conc, 1)*SIZE(conc, 2)*SIZE(conc, 3&
&                   )*SIZE(conc, 4)*SIZE(conc, 5))
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    IF (ALLOCATED(temp)) THEN
      CALL PUSHREAL8ARRAY(temp, SIZE(temp, 1)*SIZE(temp, 2)*SIZE(temp, 3&
&                   )*SIZE(temp, 4))
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    CALL CHECK_DOMAIN(ismpl)
!         summarise all convergency criteria
    lcon_sum = .true.
    DO i=1,conv_hmax
      IF (.NOT.lcon(i, ismpl)) THEN
        CALL PUSHCONTROL1B(1)
        lcon_sum = .false.
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
! generate convergency output
    IF (linfos(3) .GE. 1) THEN
      WRITE(*, '(1A,1I6,2(1A,1e16.8))') '  [I] : iter_nl =', iter_nl, &
&     ', difmaxh =', difmaxf, ', difmaxt =', difmaxt
      IF (ntrac .GE. 1) THEN
        CALL PUSHCONTROL1B(0)
        WRITE(*, '(1A,99e16.8)') '        difmaxc[*] =', (conc_conv(i, &
&       ismpl), i=1,ntrac)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (runmode .GE. -1 .AND. (.NOT.write_iter_disable)) THEN
      IF (linfos(3) .GE. 2) THEN
        CALL PUSHCONTROL1B(0)
        res = LBLANK(status_log)
        WRITE(*, '(3A)') '  [W] : "', status_log(1:res), '"'
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      OPEN(76, file=status_log, status='unknown', position='append') 
      WRITE(76, '(I11,99e16.8)') iter_nl, difmaxf, difmaxt, (conc_conv(i&
&     , ismpl), i=1,ntrac)
      CLOSE(76) 
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
! calculate total salinity (used only in property module
! basc)
    CALL SET_TSAL(ismpl)
    ad_count = ad_count + 1
  END DO
  CALL PUSHINTEGER8(ad_count)
! --------
! -------- end nonlinear iteration
! --------------------------------
! Variable time step
  IF (ALLOCATED(flag_delt)) THEN
    CALL PUSHINTEGER8ARRAY(flag_delt, SIZE(flag_delt, 1))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  CALL SET_VAR_DELTAT(iter_nl, ismpl)
! Standard output
  IF (transient .AND. tr_switch(ismpl)) THEN
    IF (linfos(3) .GE. 2) WRITE(*, '(1A,1I10,1A)') 'timestep ', &
&                         iter_time, ', leaving nonlinear iteration'
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 1) CALL POPINTEGER8ARRAY(flag_delt, SIZE(flag_delt, 1)&
&                                   )
  relaxc_ad = 0.D0
  relaxf_ad = 0.D0
  relaxt_ad = 0.D0
  difmaxc_ad = 0.D0
  difmaxf_ad = 0.D0
  difmaxt_ad = 0.D0
  CALL POPINTEGER8(ad_count)
  DO i1=1,ad_count
    CALL POPCONTROL1B(branch)
    CALL POPCONTROL1B(branch)
    DO i=conv_hmax,1,-1
      CALL POPCONTROL1B(branch)
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 1) CALL POPREAL8ARRAY(temp, SIZE(temp, 1)*SIZE(temp&
&                                   , 2)*SIZE(temp, 3)*SIZE(temp, 4))
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 1) CALL POPREAL8ARRAY(conc, SIZE(conc, 1)*SIZE(conc&
&                                   , 2)*SIZE(conc, 3)*SIZE(conc, 4)*&
&                                   SIZE(conc, 5))
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 1) CALL POPREAL8ARRAY(pres, SIZE(pres, 1)*SIZE(pres&
&                                   , 2)*SIZE(pres, 3)*SIZE(pres, 4))
    CALL CHECK_DOMAIN_AD(ismpl)
    DO species=ntrac,1,-1
      CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .EQ. 1) THEN
          arg1 = 1.0d0 - relaxc
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 1) CALL POPREAL8ARRAY(conc(1, 1, 1, species, &
&                                         ismpl), SIZE(conc, 1))
          CALL DAXPY_AD(ijk, arg1, arg1_ad, concold(1, species, cgen_fw&
&                 , ismpl), concold_ad(1, species, cgen_fw, ismpl), 1, &
&                 conc(1:, 1, 1, species, ismpl), conc_ad(1:, 1, 1, &
&                 species, ismpl), 1)
          relaxc_ad = relaxc_ad - arg1_ad
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 1) CALL POPREAL8ARRAY(conc(1, 1, 1, species, &
&                                         ismpl), SIZE(conc, 1))
          CALL DSCAL_AD(ijk, relaxc, relaxc_ad, conc(1:, 1, 1, species, &
&                 ismpl), conc_ad(1:, 1, 1, species, ismpl), 1)
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL8(relaxc)
            CALL POPREAL8(relaxold)
            CALL NL_RELAX_AD(iter_nl, difmaxc, difmaxc_ad, difmaxcold, &
&                      difmaxcold_ad, nlmaxc, relaxc, relaxc_ad, &
&                      relaxold, relaxold_ad, ismpl)
            relaxc_ad = relaxold_ad
          ELSE
            difmaxcold_ad = 0.D0
          END IF
        ELSE
          difmaxcold_ad = 0.D0
        END IF
        CALL POPREAL8(difmaxc)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 1) CALL POPREAL8ARRAY(x, SIZE(x, 1)*SIZE(x, 2)*&
&                                       SIZE(x, 3)*SIZE(x, 4))
        CALL CHECK_CHANGE_AD(mode, pv_conc, loc_nltolc, difrmsc, difmaxc&
&                      , difmaxc_ad, i0, j0, k0, conc(1, 1, 1, species, &
&                      ismpl), conc_ad(1, 1, 1, species, ismpl), concold&
&                      (1, species, cgen_fw, ismpl), concold_ad(1, &
&                      species, cgen_fw, ismpl), ismpl)
        CALL POPREAL8(difmaxcold)
        difmaxc_ad = difmaxcold_ad
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 1) CALL POPREAL8ARRAY(simtime, SIZE(simtime, 1&
&                                         ))
        END IF
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 1) CALL POPREAL8ARRAY(d, SIZE(d, 1)*SIZE(d, 2)*&
&                                       SIZE(d, 3)*SIZE(d, 4))
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 1) CALL POPREAL8ARRAY(e, SIZE(e, 1)*SIZE(e, 2)*&
&                                       SIZE(e, 3)*SIZE(e, 4))
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 1) CALL POPREAL8ARRAY(f, SIZE(f, 1)*SIZE(f, 2)*&
&                                       SIZE(f, 3)*SIZE(f, 4))
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 1) CALL POPREAL8ARRAY(g, SIZE(g, 1)*SIZE(g, 2)*&
&                                       SIZE(g, 3)*SIZE(g, 4))
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 1) CALL POPREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*&
&                                       SIZE(w, 3)*SIZE(w, 4))
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 1) CALL POPREAL8ARRAY(x, SIZE(x, 1)*SIZE(x, 2)*&
&                                       SIZE(x, 3)*SIZE(x, 4))
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 1) CALL POPREAL8ARRAY(delt_old, SIZE(delt_old, 1&
&                                       ))
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 1) CALL POPINTEGER8ARRAY(flag_1st_timestep, SIZE&
&                                          (flag_1st_timestep, 1))
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 1) CALL POPINTEGER8ARRAY(delt_count, SIZE(&
&                                          delt_count, 1))
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 1) CALL POPREAL8ARRAY(conc, SIZE(conc, 1)*SIZE(&
&                                       conc, 2)*SIZE(conc, 3)*SIZE(conc&
&                                       , 4)*SIZE(conc, 5))
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 1) CALL POPREAL8ARRAY(simtime, SIZE(simtime, 1))
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 1) CALL POPREAL8ARRAY(a, SIZE(a, 1)*SIZE(a, 2)*&
&                                       SIZE(a, 3)*SIZE(a, 4))
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 1) CALL POPREAL8ARRAY(b, SIZE(b, 1)*SIZE(b, 2)*&
&                                       SIZE(b, 3)*SIZE(b, 4))
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 1) CALL POPREAL8ARRAY(c, SIZE(c, 1)*SIZE(c, 2)*&
&                                       SIZE(c, 3)*SIZE(c, 4))
        CALL CALC_CONC_AD(species, ismpl)
      END IF
    END DO
    CALL POPCONTROL1B(branch)
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      arg1 = 1.0d0 - relaxt
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(temp(1, 1, 1, ismpl), SIZE(&
&                                     temp, 1))
      CALL DAXPY_AD(ijk, arg1, arg1_ad, tempold(1, cgen_fw, ismpl), &
&             tempold_ad(1, cgen_fw, ismpl), 1, temp(1:, 1, 1, ismpl), &
&             temp_ad(1:, 1, 1, ismpl), 1)
      relaxt_ad = relaxt_ad - arg1_ad
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(temp(1, 1, 1, ismpl), SIZE(&
&                                     temp, 1))
      CALL DSCAL_AD(ijk, relaxt, relaxt_ad, temp(1:, 1, 1, ismpl), &
&             temp_ad(1:, 1, 1, ismpl), 1)
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(relaxt)
        CALL POPREAL8(relaxold)
        CALL NL_RELAX_AD(iter_nl, difmaxt, difmaxt_ad, difmaxtold, &
&                  difmaxtold_ad, nlmaxt, relaxt, relaxt_ad, relaxold, &
&                  relaxold_ad, ismpl)
        relaxt_ad = relaxold_ad
      ELSE
        difmaxtold_ad = 0.D0
      END IF
    ELSE IF (branch .EQ. 1) THEN
      difmaxtold_ad = 0.D0
    ELSE
      GOTO 100
    END IF
    CALL POPREAL8(difmaxt)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 1) CALL POPREAL8ARRAY(x, SIZE(x, 1)*SIZE(x, 2)*SIZE(&
&                                   x, 3)*SIZE(x, 4))
    CALL CHECK_CHANGE_AD(mode, pv_temp, loc_nltolt, difrmst, difmaxt, &
&                  difmaxt_ad, i0, j0, k0, temp(1, 1, 1, ismpl), temp_ad&
&                  (1, 1, 1, ismpl), tempold(1, cgen_fw, ismpl), &
&                  tempold_ad(1, cgen_fw, ismpl), ismpl)
    CALL POPREAL8(difmaxtold)
    difmaxt_ad = difmaxtold_ad
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(simtime, SIZE(simtime, 1))
    END IF
 100 CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(d, SIZE(d, 1)*SIZE(d, 2)*&
&                                     SIZE(d, 3)*SIZE(d, 4))
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(e, SIZE(e, 1)*SIZE(e, 2)*&
&                                     SIZE(e, 3)*SIZE(e, 4))
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(f, SIZE(f, 1)*SIZE(f, 2)*&
&                                     SIZE(f, 3)*SIZE(f, 4))
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(g, SIZE(g, 1)*SIZE(g, 2)*&
&                                     SIZE(g, 3)*SIZE(g, 4))
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(temp, SIZE(temp, 1)*SIZE(&
&                                     temp, 2)*SIZE(temp, 3)*SIZE(temp, &
&                                     4))
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*&
&                                     SIZE(w, 3)*SIZE(w, 4))
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(x, SIZE(x, 1)*SIZE(x, 2)*&
&                                     SIZE(x, 3)*SIZE(x, 4))
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(delt_old, SIZE(delt_old, 1))
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPINTEGER8ARRAY(flag_1st_timestep, SIZE(&
&                                        flag_1st_timestep, 1))
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPINTEGER8ARRAY(delt_count, SIZE(&
&                                        delt_count, 1))
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(simtime, SIZE(simtime, 1))
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(a, SIZE(a, 1)*SIZE(a, 2)*&
&                                     SIZE(a, 3)*SIZE(a, 4))
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(b, SIZE(b, 1)*SIZE(b, 2)*&
&                                     SIZE(b, 3)*SIZE(b, 4))
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(c, SIZE(c, 1)*SIZE(c, 2)*&
&                                     SIZE(c, 3)*SIZE(c, 4))
      CALL CALC_TEMP_AD(ismpl)
    END IF
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      arg1 = 1.0d0 - relaxf
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(head(1, 1, 1, ismpl), SIZE(&
&                                     head, 1))
      CALL DAXPY_AD(ijk, arg1, arg1_ad, headold(1, cgen_fw, ismpl), &
&             headold_ad(1, cgen_fw, ismpl), 1, head(1:, 1, 1, ismpl), &
&             head_ad(1:, 1, 1, ismpl), 1)
      relaxf_ad = relaxf_ad - arg1_ad
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(head(1, 1, 1, ismpl), SIZE(&
&                                     head, 1))
      CALL DSCAL_AD(ijk, relaxf, relaxf_ad, head(1:, 1, 1, ismpl), &
&             head_ad(1:, 1, 1, ismpl), 1)
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(relaxf)
        CALL POPREAL8(relaxold)
        CALL NL_RELAX_AD(iter_nl, difmaxf, difmaxf_ad, difmaxfold, &
&                  difmaxfold_ad, nlmaxf, relaxf, relaxf_ad, relaxold, &
&                  relaxold_ad, ismpl)
        relaxf_ad = relaxold_ad
      ELSE
        difmaxfold_ad = 0.D0
      END IF
    ELSE IF (branch .EQ. 1) THEN
      difmaxfold_ad = 0.D0
    ELSE
      GOTO 110
    END IF
    CALL POPREAL8(difmaxf)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 1) CALL POPREAL8ARRAY(x, SIZE(x, 1)*SIZE(x, 2)*SIZE(&
&                                   x, 3)*SIZE(x, 4))
    CALL CHECK_CHANGE_AD(mode, pv_head, loc_nltolf, difrmsf, difmaxf, &
&                  difmaxf_ad, i0, j0, k0, head(1, 1, 1, ismpl), head_ad&
&                  (1, 1, 1, ismpl), headold(1, cgen_fw, ismpl), &
&                  headold_ad(1, cgen_fw, ismpl), ismpl)
    CALL POPREAL8(difmaxfold)
    difmaxf_ad = difmaxfold_ad
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(simtime, SIZE(simtime, 1))
    END IF
 110 CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(d, SIZE(d, 1)*SIZE(d, 2)*&
&                                     SIZE(d, 3)*SIZE(d, 4))
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(e, SIZE(e, 1)*SIZE(e, 2)*&
&                                     SIZE(e, 3)*SIZE(e, 4))
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(f, SIZE(f, 1)*SIZE(f, 2)*&
&                                     SIZE(f, 3)*SIZE(f, 4))
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(g, SIZE(g, 1)*SIZE(g, 2)*&
&                                     SIZE(g, 3)*SIZE(g, 4))
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*&
&                                     SIZE(w, 3)*SIZE(w, 4))
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(x, SIZE(x, 1)*SIZE(x, 2)*&
&                                     SIZE(x, 3)*SIZE(x, 4))
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(delt_old, SIZE(delt_old, 1))
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPINTEGER8ARRAY(flag_1st_timestep, SIZE(&
&                                        flag_1st_timestep, 1))
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPINTEGER8ARRAY(delt_count, SIZE(&
&                                        delt_count, 1))
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(simtime, SIZE(simtime, 1))
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(a, SIZE(a, 1)*SIZE(a, 2)*&
&                                     SIZE(a, 3)*SIZE(a, 4))
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(b, SIZE(b, 1)*SIZE(b, 2)*&
&                                     SIZE(b, 3)*SIZE(b, 4))
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(c, SIZE(c, 1)*SIZE(c, 2)*&
&                                     SIZE(c, 3)*SIZE(c, 4))
      CALL CALC_HEAD_AD(ismpl)
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 1) CALL POPREAL8ARRAY(temp, SIZE(temp, 1)*SIZE(temp&
&                                   , 2)*SIZE(temp, 3)*SIZE(temp, 4))
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 1) CALL POPREAL8ARRAY(head, SIZE(head, 1)*SIZE(head&
&                                   , 2)*SIZE(head, 3)*SIZE(head, 4))
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 1) CALL POPREAL8ARRAY(pres, SIZE(pres, 1)*SIZE(pres&
&                                   , 2)*SIZE(pres, 3)*SIZE(pres, 4))
    CALL HEAD2PRES_AD(1, ismpl)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 1) CALL POPREAL8ARRAY(delt_old, SIZE(delt_old, 1))
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 1) CALL POPREAL8ARRAY(dbc_data, SIZE(dbc_data, 1)*&
&                                   SIZE(dbc_data, 2)*SIZE(dbc_data, 3))
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 1) CALL POPINTEGER8ARRAY(flag_1st_timestep, SIZE(&
&                                      flag_1st_timestep, 1))
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 1) CALL POPINTEGER8ARRAY(delt_count, SIZE(delt_count&
&                                      , 1))
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 1) CALL POPREAL8ARRAY(simtime, SIZE(simtime, 1))
    CALL CALC_USER_AD(ismpl)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(temp, SIZE(temp, 1)*SIZE(&
&                                     temp, 2)*SIZE(temp, 3)*SIZE(temp, &
&                                     4))
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 1) CALL POPREAL8ARRAY(head, SIZE(head, 1)*SIZE(&
&                                     head, 2)*SIZE(head, 3)*SIZE(head, &
&                                     4))
      CALL STATIC_RELAXATION_AD(ijk, ismpl)
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 1) CALL POPREAL8ARRAY(concold, SIZE(concold, 1)*SIZE&
&                                   (concold, 2)*SIZE(concold, 3)*SIZE(&
&                                   concold, 4))
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 1) CALL POPREAL8ARRAY(headold, SIZE(headold, 1)*SIZE&
&                                   (headold, 2)*SIZE(headold, 3))
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 1) CALL POPREAL8ARRAY(tempold, SIZE(tempold, 1)*SIZE&
&                                   (tempold, 2)*SIZE(tempold, 3))
    CALL OLD_SAVE_AD(cgen_fw, ismpl)
    CALL POPINTEGER8(iter_nl)
  END DO
END SUBROUTINE FORWARD_PICARD_AD

