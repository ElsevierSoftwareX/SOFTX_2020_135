!        Generated by TAPENADE     (INRIA, Ecuador team)
!  tapenade 3.x
!
!  Differentiation of bhpr in forward (tangent) mode:
!   variations   of useful results: *dbc_data bhpr
!   with respect to varying inputs: *dbc_data *bcperiod *propunit
!                *pres
!   Plus diff mem management of: dbc_data:in bcperiod:in propunit:in
!                pres:in simtime:in
! MIT License
!
! Copyright (c) 2020 SHEMAT-Suite
!
! Permission is hereby granted, free of charge, to any person obtaining a copy
! of this software and associated documentation files (the "Software"), to deal
! in the Software without restriction, including without limitation the rights
! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
! copies of the Software, and to permit persons to whom the Software is
! furnished to do so, subject to the following conditions:
!
! The above copyright notice and this permission notice shall be included in all
! copies or substantial portions of the Software.
!
! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
! SOFTWARE.
!> @brief calculate well pressure according to Shu,2005
!> @param[in] ismpl local sample index
!> @param[in] ii i cell-index
!> @param[in] jj i cell-index
!> @param[in] kk i cell-index
!> @details
!> Reference: J. Shu\n COMPARISON OF VARIOUS TECHINQUES FOR COMPUTING
!> WELL INDEX\n Master Thesis, Stanford 2005\n\n
!>
!> modify coefficents for the head equation according to the boundary
!> conditions, coefficients are stored as vectors in the diagonals a-g
!> (d center), and rhs in w.\n
DOUBLE PRECISION FUNCTION g_BHPR(ii, jj, kk, ismpl, bhpr)
  USE ARRAYS

  USE g_ARRAYS

  USE MOD_GENRL
  USE MOD_GENRLC
  USE MOD_TEMP
  USE MOD_FLOW
  USE MOD_TIME

  USE g_MOD_TIME

  USE MOD_LINFOS
  IMPLICIT NONE
  INTEGER :: ismpl
  INTEGER :: i, j, k
  INTEGER :: ib
!
  INTEGER :: ii, jj, kk, bcu, tpbcu, bctype, i_dir
  DOUBLE PRECISION :: val, malfa, mbeta
  DOUBLE PRECISION :: g_val, g_malfa, g_mbeta
  DOUBLE PRECISION :: d_x, d_y, d_z, k_x, k_y, k_z, wi_x, wi_y, wi_z, &
& wi_pj
  DOUBLE PRECISION :: g_k_x, g_k_y, g_wi_z, g_wi_pj
! DOUBLE PRECISION l_x,l_y
  DOUBLE PRECISION :: l_z
  DOUBLE PRECISION :: r_b, r_w, skin
  DOUBLE PRECISION :: g_r_b
! DOUBLE PRECISION xz,zx,yz,zy
  DOUBLE PRECISION :: xy, yx
  DOUBLE PRECISION :: g_xy, g_yx
!
  EXTERNAL KX, KY, KZ, VISF
  EXTERNAL g_KX, g_KY, g_KZ
  DOUBLE PRECISION :: KX, KY, KZ, VISF
  DOUBLE PRECISION :: g_KX, g_KY, g_KZ
  PARAMETER (skin=0.d0, r_w=0.15)
!
  INTRINSIC MAX
  INTRINSIC SQRT
  INTRINSIC LOG
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: g_result1
  DOUBLE PRECISION :: result2
  DOUBLE PRECISION :: g_result2
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: g_arg1
  DOUBLE PRECISION :: result3
  DOUBLE PRECISION :: g_result3
  DOUBLE PRECISION :: temp0
  DOUBLE PRECISION :: temp1
  DOUBLE PRECISION :: bhpr
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
! dirichlet nodes - - - - - - - - - - - - - - - - - - - - - - - - - - -
! neumann  nodes    - - - - - - - - - - - - - - - - - - - - - - - - - -
!
! default well pressure
  bhpr = 0.0d0
  g_bhpr = 0.D0
  DO ib=first_flow,last_flow
    i = ibc_data(ib, cbc_i)
    j = ibc_data(ib, cbc_j)
    k = ibc_data(ib, cbc_k)
    bctype = ibc_data(ib, cbc_bt)
! neumann bc?, skip otherwise
! data point? skip otherwise
    IF (ii .EQ. i .AND. jj .EQ. j .AND. kk .EQ. k .AND. bctype .EQ. &
&       bt_neuw) THEN
      bcu = ibc_data(ib, cbc_bcu)
      IF (ibc_data(ib, cbc_bctp) .LT. 0) THEN
        tpbcu = 0
      ELSE
        tpbcu = ibc_data(ib, cbc_bctp)
      END IF
      i_dir = ibc_data(ib, cbc_dir)
! WELLMODEL
! discrete values
      g_val = g_dbc_data(ib, 1, ismpl)
      val = dbc_data(ib, 1, ismpl)
      IF (tpbcu .GT. 0 .AND. nbctp .GT. 0) THEN
! time-dependent bc:  val=ac*val+bc
! get Alfa and Beta modificators
        CALL g_GET_TPBCALBE(malfa, g_malfa, mbeta, g_mbeta, tpbcu&
&                       , ismpl)
! update time dependend modification of the bc-value
        g_val = g_malfa + val*g_mbeta + mbeta*g_val
        val = malfa + mbeta*val
      END IF
!
      IF (tpbcu .GE. 0) THEN
        g_k_x = g_KX(i, j, k, ismpl, k_x)
        g_k_y = g_KY(i, j, k, ismpl, k_y)
        k_z = KZ(i, j, k, ismpl)
        d_x = delx(i)
        d_y = dely(j)
        d_z = delz(k)
!             l_x=0.d0
!             yz=k_y/k_z
!             zy=k_z/k_y
!             r_b=0.28d0*sqrt((sqrt(yz)*d_z**2+sqrt(zy)*d_y**2))/ &
!                                       (yz**0.25+zy**0.25)
!             wi_x = 2.0d0*pi*sqrt(k_y*k_z)*l_x/(log(r_b/r_w)+skin)
        wi_x = 0.0d0
!             l_y=0.d0
!             xz=k_x/k_z
!             zx=k_z/k_x
!             r_b=0.28d0*sqrt((sqrt(xz)*d_z**2+sqrt(zx)*d_x**2))/ &
!                                       (xz**0.25+zx**0.25)
!             wi_y = 2.0d0*pi*sqrt(k_x*k_z)*l_y/(log(r_b/r_w)+skin)
        wi_y = 0.0d0
        l_z = d_z
        g_xy = (g_k_x-k_x*g_k_y/k_y)/k_y
        xy = k_x/k_y
        g_yx = (g_k_y-k_y*g_k_x/k_x)/k_x
        yx = k_y/k_x
        temp0 = SQRT(xy)
        IF (xy .EQ. 0.0) THEN
          g_result1 = 0.D0
        ELSE
          g_result1 = g_xy/(2.0*temp0)
        END IF
        result1 = temp0
        temp0 = SQRT(yx)
        IF (yx .EQ. 0.0) THEN
          g_result2 = 0.D0
        ELSE
          g_result2 = g_yx/(2.0*temp0)
        END IF
        result2 = temp0
        g_arg1 = d_y**2*g_result1 + d_x**2*g_result2
        arg1 = result1*d_y**2 + result2*d_x**2
        temp0 = SQRT(arg1)
        IF (arg1 .EQ. 0.0) THEN
          g_result3 = 0.D0
        ELSE
          g_result3 = g_arg1/(2.0*temp0)
        END IF
        result3 = temp0
        temp0 = xy**0.25 + yx**0.25
        g_r_b = 0.28d0*(g_result3-result3*(0.25*xy**(-0.75)*g_xy+&
&         0.25*yx**(-0.75)*g_yx)/temp0)/temp0
        r_b = 0.28d0*(result3/temp0)
        g_arg1 = k_y*g_k_x + k_x*g_k_y
        arg1 = k_x*k_y
        temp0 = SQRT(arg1)
        IF (arg1 .EQ. 0.0) THEN
          g_result1 = 0.D0
        ELSE
          g_result1 = g_arg1/(2.0*temp0)
        END IF
        result1 = temp0
        temp0 = 2.0d0*pi*l_z
        temp1 = skin + LOG(r_b/r_w)
        g_wi_z = temp0*(g_result1-result1*g_r_b/(temp1*r_b))/temp1
        wi_z = temp0*(result1/temp1)
        g_arg1 = 2*wi_z*g_wi_z
        arg1 = wi_x**2 + wi_y**2 + wi_z**2
        temp1 = SQRT(arg1)
        IF (arg1 .EQ. 0.0) THEN
          g_wi_pj = 0.D0
        ELSE
          g_wi_pj = g_arg1/(2.0*temp1)
        END IF
        wi_pj = temp1
        result1 = VISF(i, j, k, ismpl)
        g_bhpr = g_pres(i, j, k, ismpl) + result1*(g_val-val*&
&         g_wi_pj/wi_pj)/wi_pj
        bhpr = pres(i, j, k, ismpl) + val*result1/wi_pj
        g_dbc_data(ib, 3, ismpl) = g_bhpr
        dbc_data(ib, 3, ismpl) = bhpr
      END IF
    END IF
  END DO
!
!
  RETURN
END FUNCTION g_BHPR

