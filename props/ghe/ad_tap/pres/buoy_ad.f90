!        Generated by TAPENADE     (INRIA, Ecuador team)
!  tapenade 3.x
!
!  Differentiation of buoy in reverse (adjoint) mode (with options noISIZE i8):
!   gradient     of useful results: *temp *propunit *pres buoy
!   with respect to varying inputs: *temp *propunit *pres
!   Plus diff mem management of: temp:in pres:in
! MIT License
!
! Copyright (c) 2020 SHEMAT-Suite
!
! Permission is hereby granted, free of charge, to any person obtaining a copy
! of this software and associated documentation files (the "Software"), to deal
! in the Software without restriction, including without limitation the rights
! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
! copies of the Software, and to permit persons to whom the Software is
! furnished to do so, subject to the following conditions:
!
! The above copyright notice and this permission notice shall be included in all
! copies or substantial portions of the Software.
!
! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
! SOFTWARE.
!>    @brief calculate buoyancy for pressure equation
!>    @param[in] i cell index, direction I0
!>    @param[in] j cell index, direction J0
!>    @param[in] k cell index, direction K0
!>    @param[in] ismpl local sample index
!>    @return buoyancy for pressure
!>    @details
!> calculate buoyancy for pressure equation\n
!> sign convention: negative for positive buoyancy\n
!> if porosity is 1.E-20, the pressure is set to!> atmospheric pressure      
SUBROUTINE BUOY_AD(i, j, k, ismpl, buoy_adv)
  use arrays

  USE ARRAYS_AD

  USE MOD_GENRL
  USE MOD_FLOW
  IMPLICIT NONE
  double precision :: buoy_adv
  INTEGER :: ismpl
  INTEGER :: i, j, k
  DOUBLE PRECISION :: rhav, hh, h0, h1, prod, summ
  DOUBLE PRECISION :: rhav_ad, hh_ad, h0_ad, h1_ad, prod_ad, summ_ad
  EXTERNAL RHOF, KZ, VISF, POR
  EXTERNAL RHOF_AD, KZ_AD, VISF_AD
  DOUBLE PRECISION :: RHOF, KZ, VISF, POR, &
& rh1, rh2
  DOUBLE PRECISION :: rh1_ad, rh2_ad
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: result1_ad
  INTEGER :: arg1
  DOUBLE PRECISION :: result2
  DOUBLE PRECISION :: result2_ad
  INTEGER :: arg2
  DOUBLE PRECISION :: temporary_ad
  INTEGER :: branch
  DOUBLE PRECISION :: buoy
  result1 = POR(i, j, k, ismpl)
  IF (result1 .LT. 1.e-19) THEN
    CALL PUSHCONTROL1B(0)
    rh1 = 1.29e0
  ELSE
    rh1 = RHOF(i, j, k, ismpl)
    CALL PUSHCONTROL1B(1)
  END IF
  arg1 = k + 1
  result1 = POR(i, j, arg1, ismpl)
  IF (result1 .LT. 1.e-19) THEN
    CALL PUSHCONTROL1B(0)
    rh2 = 1.29e0
  ELSE
    arg1 = k + 1
    rh2 = RHOF(i, j, arg1, ismpl)
    CALL PUSHCONTROL1B(1)
  END IF
  rhav = 0.5d0*(rh1+rh2)
  hh = 0.d0
  result1 = KZ(i, j, k, ismpl)
  result2 = VISF(i, j, k, ismpl)
  h0 = result1/result2
  arg1 = k + 1
  CALL PUSHREAL8(result1)
  result1 = KZ(i, j, arg1, ismpl)
  arg2 = k + 1
  CALL PUSHREAL8(result2)
  result2 = VISF(i, j, arg2, ismpl)
  h1 = result1/result2
  summ = h0 + h1
  prod = h0*h1
  IF (summ .GT. 0.d0) THEN
    hh = 2.0d0*prod/summ
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  hh_ad = rhav*grav*buoy_adv
  rhav_ad = hh*grav*buoy_adv
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    temporary_ad = 2.0d0*hh_ad/summ
    prod_ad = temporary_ad
    summ_ad = -(prod*temporary_ad/summ)
  ELSE
    prod_ad = 0.D0
    summ_ad = 0.D0
  END IF
  h0_ad = h1*prod_ad + summ_ad
  h1_ad = h0*prod_ad + summ_ad
  result1_ad = h1_ad/result2
  result2_ad = -(result1*h1_ad/result2**2)
  CALL POPREAL8(result2)
  CALL VISF_AD(i, j, arg2, ismpl, result2_ad)
  CALL POPREAL8(result1)
  CALL KZ_AD(i, j, arg1, ismpl, result1_ad)
  result1_ad = h0_ad/result2
  result2_ad = -(result1*h0_ad/result2**2)
  CALL VISF_AD(i, j, k, ismpl, result2_ad)
  CALL KZ_AD(i, j, k, ismpl, result1_ad)
  rh1_ad = 0.5d0*rhav_ad
  rh2_ad = 0.5d0*rhav_ad
  CALL POPCONTROL1B(branch)
  IF (branch .NE. 0) THEN
    arg1 = k + 1
    CALL RHOF_AD(i, j, arg1, ismpl, rh2_ad)
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .NE. 0) CALL RHOF_AD(i, j, k, ismpl, rh1_ad)
END SUBROUTINE BUOY_AD

