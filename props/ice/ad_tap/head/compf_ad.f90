!        Generated by TAPENADE     (INRIA, Ecuador team)
!  tapenade 3.x
!
!  Differentiation of compf in reverse (adjoint) mode (with options noISIZE i8):
!   gradient     of useful results: *temp *pres compf
!   with respect to varying inputs: *temp *pres
!   Plus diff mem management of: temp:in pres:in
! MIT License
!
! Copyright (c) 2020 SHEMAT-Suite
!
! Permission is hereby granted, free of charge, to any person obtaining a copy
! of this software and associated documentation files (the "Software"), to deal
! in the Software without restriction, including without limitation the rights
! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
! copies of the Software, and to permit persons to whom the Software is
! furnished to do so, subject to the following conditions:
!
! The above copyright notice and this permission notice shall be included in all
! copies or substantial portions of the Software.
!
! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
! SOFTWARE.
!>    @brief compf calculates compressibility of pure water
!>    @param[in] i cell index, direction I0
!>    @param[in] j cell index, direction J0
!>    @param[in] k cell index, direction K0
!>    @param[in] ismpl local sample index
!>    @return  compressibility                     compf  [1./Pa]
!>    @details
!>    compf calculates compressibility of pure water \n
!>    given temperature (t, in C), and pressure (p,in Pa)\n
!>    at node(plocal,tlocal).\n
!>    method: compf = 1/rhof d/dP rhof, rhof= fluid density.\n
!>    derived from the formulation given in:\n
!>          zylkovskij et al: models and methods summary for\n
!>          the fehmn application,\n
!>           ecd 22, la-ur-94-3787, los alamos nl, 1994.\n
!>    range of validity:\n
!>                   pressures      0.01 - 110 MPa,\n
!>                   temperature   0.001 - 350 °C and -46°C - 0°C\n
!>    input:\n
!>      pressure                               plocal [Pa]\n
!>      temperature                         tlocal in [C]\n
SUBROUTINE COMPF_AD0(i, j, k, ismpl, compf_ad)
  use arrays

  USE ARRAYS_AD

  USE MOD_FLOW
  IMPLICIT NONE
  INTEGER :: i, j, k, ismpl
  DOUBLE PRECISION :: cf(20), bf(6)
  DOUBLE PRECISION :: ta, tb, da, db, b2, rhof_loc, drhodp, t, t2, t3, &
& tlocal, tred, p, p2, p3, p4, plocal, tp, t2p, tp2
  DOUBLE PRECISION :: ta_ad, tb_ad, da_ad, db_ad, b2_ad, rhof_loc_ad, &
& drhodp_ad, t_ad, t2_ad, t3_ad, tlocal_ad, tred_ad, p_ad, p2_ad, p3_ad&
& , plocal_ad, tp_ad, t2p_ad, tp2_ad
  INTRINSIC SQRT
  DOUBLE PRECISION :: temp0
  DOUBLE PRECISION :: temporary_ad
  INTEGER :: branch
  DOUBLE PRECISION :: compf
  DOUBLE PRECISION :: compf_ad
  DATA cf /0.10000000d+01, 0.17472599d-01, -0.20443098d-04, -&
&      0.17442012d-06, 0.49564109d-02, -0.40757664d-04, 0.50676664d-07, &
&      0.50330978d-04, 0.33914814d-06, -0.18383009d-06, 0.10009476d-02, &
&      0.16812589d-04, -0.24582622d-07, -0.17014984d-09, 0.48841156d-05&
&      , -0.32967985d-07, 0.28619380d-10, 0.53249055d-07, 0.30456698d-09&
&      , -0.12221899d-09/
!     new: after Speedy (1987) for T < 0 to -46 C
  DATA bf /20.d0, 4.12d0, -1.13d0, 77.817d0, -78.143d0, 54.29d0/
!     end new
  plocal = pres(i, j, k, ismpl)*pa_conv1
  tlocal = temp(i, j, k, ismpl)
  IF (tlocal .LT. -45d0) THEN
    tlocal = -45.d0
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  IF (tlocal .LT. 0.d0) THEN
!     new: after Speedy (1987) for T < 0 to -46 C
    tred = (tlocal+273.15d0-227.15d0)/227.15d0
    compf_ad = 1.d-11*compf_ad
    temp0 = SQRT(tred)
    IF (tred .EQ. 0.0) THEN
      tred_ad = (bf(3)+2*tred*bf(4)+3*tred**2*bf(5)+4*tred**3*bf(6))*&
&       compf_ad
    ELSE
      tred_ad = (bf(3)+2*tred*bf(4)+3*tred**2*bf(5)+4*tred**3*bf(6)-bf(1&
&       )/(2.0*temp0**3))*compf_ad
    END IF
    tlocal_ad = tred_ad/227.15d0
    plocal_ad = 0.D0
  ELSE
!     end new
    IF (tlocal .GT. 300.d0) THEN
      tlocal = 300.d0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    p = plocal
    t = tlocal
    p2 = p*p
    p3 = p2*p
    t2 = t*t
    t3 = t2*t
    tp = p*t
    t2p = t2*p
    tp2 = t*p2
! liquid density
    ta = cf(1) + cf(2)*p + cf(3)*p2 + cf(4)*p3 + cf(5)*t + cf(6)*t2 + cf&
&     (7)*t3 + cf(8)*tp + cf(10)*t2p + cf(9)*tp2
    tb = cf(11) + cf(12)*p + cf(13)*p2 + cf(14)*p3 + cf(15)*t + cf(16)*&
&     t2 + cf(17)*t3 + cf(18)*tp + cf(20)*t2p + cf(19)*tp2
    rhof_loc = ta/tb
! derivative C   C2+2*C3*p+3*C4*p^2+C8*t+C10*t^2+2*C9*t*p
    da = cf(2) + 2.d0*cf(3)*p + 3.d0*cf(4)*p2 + cf(8)*t + 2.d0*cf(9)*tp &
&     + cf(10)*t2
! derivative C12+2*C13*p+3*C14*p^2+C18*t+C20*t^2+2*C19*t*p
    db = cf(12) + 2.d0*cf(13)*p + 3.d0*cf(14)*p2 + cf(18)*t + 2.0*cf(19)&
&     *tp + cf(20)*t2
    b2 = tb*tb
    drhodp = (da*tb-ta*db)/b2
!      Compf=rhof_loc/drhodp
!      Compf=rhof_loc
    temporary_ad = 1.e-6*compf_ad/rhof_loc
    drhodp_ad = temporary_ad
    rhof_loc_ad = -(drhodp*temporary_ad/rhof_loc)
    temporary_ad = drhodp_ad/b2
    da_ad = tb*temporary_ad
    ta_ad = rhof_loc_ad/tb - db*temporary_ad
    db_ad = -(ta*temporary_ad)
    b2_ad = -((da*tb-ta*db)*temporary_ad/b2)
    tb_ad = da*temporary_ad + 2*tb*b2_ad - ta*rhof_loc_ad/tb**2
    tp_ad = 2.0*cf(19)*db_ad + 2.d0*cf(9)*da_ad + cf(18)*tb_ad + cf(8)*&
&     ta_ad
    p3_ad = cf(14)*tb_ad + cf(4)*ta_ad
    t3_ad = cf(17)*tb_ad + cf(7)*ta_ad
    t2p_ad = cf(20)*tb_ad + cf(10)*ta_ad
    t2_ad = cf(20)*db_ad + cf(10)*da_ad + cf(16)*tb_ad + cf(6)*ta_ad + p&
&     *t2p_ad + t*t3_ad
    tp2_ad = cf(19)*tb_ad + cf(9)*ta_ad
    p2_ad = 3.d0*cf(14)*db_ad + 3.d0*cf(4)*da_ad + cf(13)*tb_ad + cf(3)*&
&     ta_ad + t*tp2_ad + p*p3_ad
    p_ad = 2.d0*cf(13)*db_ad + 2.d0*cf(3)*da_ad + cf(12)*tb_ad + cf(2)*&
&     ta_ad + t2*t2p_ad + t*tp_ad + p2*p3_ad + 2*p*p2_ad
    t_ad = cf(18)*db_ad + cf(8)*da_ad + cf(15)*tb_ad + cf(5)*ta_ad + p2*&
&     tp2_ad + p*tp_ad + t2*t3_ad + 2*t*t2_ad
    tlocal_ad = t_ad
    plocal_ad = p_ad
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) tlocal_ad = 0.D0
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) tlocal_ad = 0.D0
  temp_ad(i, j, k, ismpl) = temp_ad(i, j, k, ismpl) + tlocal_ad
  pres_ad(i, j, k, ismpl) = pres_ad(i, j, k, ismpl) + pa_conv1*plocal_ad
END SUBROUTINE COMPF_AD0

