!        Generated by TAPENADE     (INRIA, Ecuador team)
!  tapenade 3.x
!
!  Differentiation of lx in reverse (adjoint) mode (with options noISIZE i8):
!   gradient     of useful results: *temp *propunit lx
!   with respect to varying inputs: *temp *propunit
!   Plus diff mem management of: temp:in propunit:in
! MIT License
!
! Copyright (c) 2020 SHEMAT-Suite
!
! Permission is hereby granted, free of charge, to any person obtaining a copy
! of this software and associated documentation files (the "Software"), to deal
! in the Software without restriction, including without limitation the rights
! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
! copies of the Software, and to permit persons to whom the Software is
! furnished to do so, subject to the following conditions:
!
! The above copyright notice and this permission notice shall be included in all
! copies or substantial portions of the Software.
!
! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
! SOFTWARE.
!>    @brief calculates effective thermal conductivity of the two phase
!>    @param[in] i cell index, direction I0
!>    @param[in] j cell index, direction J0
!>    @param[in] k cell index, direction K0
!>    @param[in] ismpl local sample index
!>    @return  thermal conductivity                lx[W/(m*K)]
!>    @details
!>    calculates effective thermal conductivity of the two phase\n
!>    system matrix-porosity .\n
!>    input:\n
!>      porosity                            porlocal [-]\n
!>      pressure                            plocal [Mpa]\n
!>      temperature                         tlocal in [C]\n
SUBROUTINE LX_AD(i, j, k, ismpl, lx_adv)
  use arrays

  USE ARRAYS_AD

  USE ICE
  USE MOD_TEMP
  IMPLICIT NONE
  double precision :: lx_adv
  INTEGER :: i, j, k, ui, ismpl
  DOUBLE PRECISION :: tlocal, lsolid, lfluid, porlocal, fm, fi, ff
  DOUBLE PRECISION :: tlocal_ad, lsolid_ad, lfluid_ad, porlocal_ad, &
& fm_ad, fi_ad, ff_ad
  DOUBLE PRECISION :: t0, theta, dtheta, w0, lice
  DOUBLE PRECISION :: theta_ad, dtheta_ad, lice_ad
  EXTERNAL LAMF, LAMM, LAMI, POR
  EXTERNAL LAMF_AD, LAMM_AD, LAMI_AD, POR_AD
  DOUBLE PRECISION :: LAMM, LAMF, LAMI, POR
  INTRINSIC ABS
  DOUBLE PRECISION :: abs0
  DOUBLE PRECISION :: tmp
  DOUBLE PRECISION :: tmp_ad
  DOUBLE PRECISION :: temp0
  DOUBLE PRECISION :: temporary_ad
  DOUBLE PRECISION :: temp1
  DOUBLE PRECISION :: temp2
  DOUBLE PRECISION :: temporary_ad0
  DOUBLE PRECISION :: lx
  ui = uindex(i, j, k)
  tlocal = temp(i, j, k, ismpl)
  t0 = liq(i, j, k)
  IF (liq(i, j, k) - sol(i, j, k) .GE. 0.) THEN
    abs0 = liq(i, j, k) - sol(i, j, k)
  ELSE
    abs0 = -(liq(i, j, k)-sol(i, j, k))
  END IF
  w0 = abs0/2.d0
  CALL FTHETA(tlocal, t0, w0, theta, dtheta, ismpl)
  lfluid = LAMF(i, j, k, ismpl)
  lice = LAMI(i, j, k, ismpl)
  lsolid = propunit(ui, idx_lz, ismpl)*propunit(ui, idx_an_lx, ismpl)
  tmp = LAMM(lsolid, tlocal, tref, ismpl)
  CALL PUSHREAL8(lsolid)
  lsolid = tmp
  porlocal = POR(i, j, k, ismpl)
  fm = 1.d0 - porlocal
  ff = porlocal*theta
  fi = porlocal - ff
  temp0 = lice**fi
  temp1 = lfluid**ff
  temp2 = lsolid**fm
  temporary_ad = temp0*lx_adv
  temporary_ad0 = temp2*temp1*lx_adv
  IF (lice .LE. 0.0 .AND. (fi .EQ. 0.0 .OR. fi .NE. INT(fi))) THEN
    lice_ad = 0.D0
  ELSE
    lice_ad = fi*lice**(fi-1)*temporary_ad0
  END IF
  IF (lice .LE. 0.0) THEN
    fi_ad = 0.D0
  ELSE
    fi_ad = temp0*LOG(lice)*temporary_ad0
  END IF
  IF (lsolid .LE. 0.0 .AND. (fm .EQ. 0.0 .OR. fm .NE. INT(fm))) THEN
    lsolid_ad = 0.D0
  ELSE
    lsolid_ad = fm*lsolid**(fm-1)*temp1*temporary_ad
  END IF
  IF (lsolid .LE. 0.0) THEN
    fm_ad = 0.D0
  ELSE
    fm_ad = temp2*LOG(lsolid)*temp1*temporary_ad
  END IF
  IF (lfluid .LE. 0.0 .AND. (ff .EQ. 0.0 .OR. ff .NE. INT(ff))) THEN
    lfluid_ad = 0.D0
  ELSE
    lfluid_ad = ff*lfluid**(ff-1)*temp2*temporary_ad
  END IF
  IF (lfluid .LE. 0.0) THEN
    ff_ad = -fi_ad
  ELSE
    ff_ad = temp1*LOG(lfluid)*temp2*temporary_ad - fi_ad
  END IF
  porlocal_ad = fi_ad + theta*ff_ad - fm_ad
  theta_ad = porlocal*ff_ad
  CALL POR_AD(i, j, k, ismpl, porlocal_ad)
  CALL POPREAL8(lsolid)
  tmp_ad = lsolid_ad
  lsolid_ad = 0.D0
  CALL LAMM_AD(lsolid, lsolid_ad, tlocal, tlocal_ad, tref, ismpl, tmp_ad&
&       )
  propunit_ad(ui, idx_lz, ismpl) = propunit_ad(ui, idx_lz, ismpl) + &
&   propunit(ui, idx_an_lx, ismpl)*lsolid_ad
  propunit_ad(ui, idx_an_lx, ismpl) = propunit_ad(ui, idx_an_lx, ismpl) &
&   + propunit(ui, idx_lz, ismpl)*lsolid_ad
  CALL LAMI_AD(i, j, k, ismpl, lice_ad)
  CALL LAMF_AD(i, j, k, ismpl, lfluid_ad)
  dtheta_ad = 0.D0
  CALL FTHETA_AD(tlocal, tlocal_ad, t0, w0, theta, theta_ad, dtheta, &
&          dtheta_ad, ismpl)
  temp_ad(i, j, k, ismpl) = temp_ad(i, j, k, ismpl) + tlocal_ad
END SUBROUTINE LX_AD

